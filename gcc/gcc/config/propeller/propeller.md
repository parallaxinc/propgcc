;; Machine description for Propeller
;; Copyright (C) 2011 Parallax, Inc.
;; Copyright (C) 2009 Free Software Foundation, Inc.
;; Contributed by Eric R. Smith <ersmith@totalspectrum.ca>
;; Based in part on the Moxie machine description
;;   contributed by Anthony Green <green@moxielogic.com>

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published
;; by the Free Software Foundation; either version 3, or (at your
;; option) any later version.

;; GCC is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
;; License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; -------------------------------------------------------------------------
;; Propeller specific constraints, predicates and attributes
;; -------------------------------------------------------------------------

;; defines for specific registers of interest
;; some of these are also used in propeller.h

;;
;;  
(define_constants
  [
   (FRAME_REG 14)
   (LINK_REG 15)
   (SP_REG 16)
   (LMM_PC_REG 17)
   (CC_REG 18)
  ]
)

(define_constants
  [
   (STORE_FLAG_VALUE 1)
  ]
)

; for builtins
(define_constants
  [
   (UNSPEC_COGID	 0)
   (UNSPEC_COGINIT	 1)
   (UNSPEC_COGSTOP	 2)
   (UNSPEC_COGSTATE      3)
   (UNSPEC_REVERSE       4)
   (UNSPEC_WAITCNT       5)
   (UNSPEC_WAITPEQ       6)
   (UNSPEC_WAITPNE       7)
   (UNSPEC_WAITVID       8)
   (UNSPEC_FCACHE_LOAD   9)
   (UNSPEC_CONST_WORD   10)
   (UNSPEC_LOCKSTATE    11)
   (UNSPEC_LOCKNEW      12)
   (UNSPEC_LOCKRET      13)
   (UNSPEC_LOCKCLR      14)
   (UNSPEC_LOCKSET      15)
   (UNSPEC_PUSHM        16)
   (UNSPEC_POPM         17)
   (UNSPEC_CLKSET       18)
   (UNSPEC_CAS          19)

   (UNSPEC_MOVMEM       20)

   (UNSPEC_NAKED_RET   101)
   (UNSPEC_NATIVE_RET  102)
   (UNSPEC_LOOP_START  103)
   (UNSPEC_LOOP_END    104)
  ; for FCACHE operations
   (UNSPEC_FCACHE_LABEL_REF 121)
   (UNSPEC_FCACHE_RET       122)
   (UNSPEC_FCACHE_CALL      123)
   (UNSPEC_FCACHE_FUNC_START  124)
   (UNSPEC_FCACHE_DONE      125)

  ])

; Most instructions are four bytes long.
(define_attr "length" "" (const_int 4))

(include "constraints.md")
(include "predicates.md")

;;
;; instruction types
;; core == normal instruction
;; call == subroutine call
;; hub  == instruction that references hub memory
;; wait == a wait instruction
;; multi == an insn that expands to multiple instructions
;;
(define_attr "type" "core,call,hub,wait,multi" (const_string "core"))

; condition codes: this one is used by final_prescan_insn to speed up
; conditionalizing instructions.  It saves having to scan the rtl to see if
; it uses or alters the condition codes.
; 
; USE means that the condition codes are used by the insn in the process of
;   outputting code, this means (at present) that we can't use the insn in
;   inlined branches
;
; SET means that the purpose of the insn is to set the condition codes in a
;   well defined manner.
;
; CLOB means that the condition codes are altered in an undefined manner, if
;   they are altered at all
;
; UNCONDITIONAL means the instruction can not be conditionally executed and
;   that the instruction does not use or alter the condition codes.
;
; NOCOND means that the instruction does not use or alter the condition
;   codes but can be converted into a conditionally exectuted instruction.

(define_attr "conds" "use,set,clob,unconditional,nocond"
	(if_then_else
	 (ior
           (eq_attr "type" "call")
           (eq_attr "type" "multi"))
	 (const_string "clob")
         (const_string "nocond")))

; Predicable means that the insn can be conditionally executed based on
; an automatically added predicate (additional patterns are generated by 
; gen...).
(define_attr "predicable" "no,yes" (const_string "no"))


;;
;; the user's __asm__ instruction has the following attributes
;;
(define_asm_attributes
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")
  (set_attr "predicable" "no")
 ])


;; -------------------------------------------------------------------------
;; machine model for instruction scheduling
;; the tricky part here is that hub memory operations are only available
;; every 16 cycles (4 instructions) and that 16 cycle period is independent
;; of what's going on inside the processor -- if we miss a hub window we
;; have to wait for the next one to come along
;;
;; we model this by pretending there are 4 slots; core operations issue
;; to any of the slots, hub operations can only issue to slot1
;; -------------------------------------------------------------------------
(define_cpu_unit "issue,slot1,slot2,slot3,slot4")

(define_reservation "use_slot1" "(issue+slot1),slot1*3")
(define_reservation "use_slot2" "(issue+slot2),slot2*3")
(define_reservation "use_slot3" "(issue+slot3),slot3*3")
(define_reservation "use_slot4" "(issue+slot4),slot4*3")

(define_insn_reservation "coreop" 1 (eq_attr "type" "core")
			 "use_slot1 | use_slot2 | use_slot3 | use_slot4")
(define_insn_reservation "hubop" 1 (eq_attr "type" "hub,wait")
			 "(issue+slot1+slot2),(slot1+slot2)*3")
(define_insn_reservation "multiop" 1 (eq_attr "type" "multi,call")
			 "issue+slot1,nothing*3")

;; -------------------------------------------------------------------------
;; general template for conditional execution
;; -------------------------------------------------------------------------
(define_cond_exec
  [(match_operator 0 "predicate_operator"
    [(match_operand 1 "cc_register" "")
     (const_int 0)])]
  ""
  "%p0"
)

;; -------------------------------------------------------------------------
;; the instruction set is pretty regular, so we define some iterators
;; to make repetitive patterns easier
;; -------------------------------------------------------------------------

(define_code_iterator orop
		        [(ior "") (xor "")])
(define_code_iterator shiftop
		        [(ashift "") (ashiftrt "") (lshiftrt "")
			 (rotate "") (rotatert "")
			])
(define_code_iterator minmaxop
		      [(umax "")(umin "") (smax "")(smin "")])
(define_code_iterator oneop
		       [(abs "")(neg "")])


(define_code_attr     opcode
		        [(plus "add") (minus "sub") (ior "or") (xor "xor")
                      	 (ashift "shl") (ashiftrt "sar") (lshiftrt "shr")
			 (rotate "rol") (rotatert "ror")
			 ;; propeller has backwards max and min names
			 (umax "min") (umin "max")
			 (smax "mins") (smin "maxs")
			 ;; abs and neg
			 (abs "abs") (neg "neg")
			 ])

(define_code_iterator muxcond [ne eq lt ge ltu geu])
(define_code_attr muxcc [(ne "nz") (eq "z") (lt "c") (ltu "c")
                         (ge "nc") (geu "nc")])
(define_code_attr muxccmode [(ne "CC_Z") (eq "CC_Z") (lt "CC") (ltu "CC_C")
                             (ge "CC") (geu "CC_C")])

(define_code_iterator ltugeu [ltu geu])

;; types of condition codes we can branch on
(define_mode_iterator BRCC [CC CCUNS CC_C CC_Z])

;; single flag modes
(define_mode_iterator CC_F [CC_Z CC_C])

;; -------------------------------------------------------------------------
;; nop instruction
;; -------------------------------------------------------------------------

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")

;; -------------------------------------------------------------------------
;; Arithmetic instructions
;; -------------------------------------------------------------------------

;;
;; special case for CMM mode -- we have a leasp macro which will 
;; add the sp to an 8 byte offset:
;;    leasp rN, #x
;; is the same as
;;    addsi rN, sp, #x
;;
(define_insn "*leasp_cmm"
  [(set (match_operand:SI        0 "propeller_gpr_operand" "=r")
        (plus:SI
              (reg:SI SP_REG)
              (match_operand:SI  1 "immediate_byte" "n")))]
  "TARGET_CMM && reload_completed"
  "leasp %0,%1"
 [(set_attr "length" "2")
  (set_attr "type" "multi")
 ]
)

;; normal add
(define_insn "addsi3"
  [(set (match_operand:SI    0 "propeller_dst_operand" "=rC,rC")
	  (plus:SI
	   (match_operand:SI 1 "propeller_dst_operand" "%0,0")
	   (match_operand:SI 2 "propeller_add_operand" " rCI,N")))]
  ""
  "@
  add\t%0, %2
  sub\t%0, #%n2"
  [(set_attr "predicable" "yes")]
)

(define_insn "subsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	  (minus:SI
	   (match_operand:SI 1 "propeller_dst_operand" "0")
	   (match_operand:SI 2 "propeller_src_operand" "rCI")))]
  ""
  "sub\t%0, %2"
  [(set_attr "predicable" "yes")]
)

;;
;; versions which set flags
;;

;; NOTE: combine does some funky canonicalizations. In particular, it
;; changes (compare (x+y) 0) to (compare x (-y)), so write the pattern
;; accordingly
;; But elsewhere we may need the other pattern...
;;
(define_insn "*addsi3_compare0_neg"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
		(match_operand:SI 1 "propeller_dst_operand" "%0,0")
                (neg:SI(match_operand:SI 2 "propeller_add_operand"  "rCI,N"))))
  (set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	  (plus:SI (match_dup 1)(match_dup 2)))]
  ""
  "@
   add\t%0, %2 wz
   sub\t%0, #%n2 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)
(define_insn "*addsi3_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	    (plus:SI (match_operand:SI 1 "propeller_dst_operand" "%0,0")
                     (match_operand:SI 2 "propeller_add_operand"  "rCI,N"))
	    (const_int 0)))
  (set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	  (plus:SI (match_dup 1)(match_dup 2)))]
  ""
  "@
   add\t%0, %2 wz
   sub\t%0, #%n2 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)
(define_insn "*addsi3_compare0_only"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	    (plus:SI (match_operand:SI 0 "propeller_dst_operand" "rC,rC")
                     (match_operand:SI 1 "propeller_add_operand" "rCI,N"))
            (const_int 0)))
   ]
  ""
  "@
   add\t%0,%1 nr,wz
   sub\t%0,#%n1 nr,wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)
(define_insn "*addsi3_compare0_neg_only"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	    (match_operand:SI 0 "propeller_dst_operand" "rC,rC")
            (neg:SI (match_operand:SI 1 "propeller_add_operand" "rCI,N"))))
   ]
  ""
  "@
   add\t%0,%1 nr,wz
   sub\t%0,#%n1 nr,wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

;; sometimes we want to set the carry flag; this essentially
;; means comparing the output with the inputs (if (x+y)<y or (x+y)<x
;; then there was carry)

(define_insn "*addsi3_set_carry1"
  [(set (reg:CC_C CC_REG)
        (compare:CC_C
          (plus:SI (match_operand:SI 1 "propeller_dst_operand" "%0,0")
                   (match_operand:SI 2 "propeller_add_operand"  "rCI,N"))
          (match_dup 1)))
  (set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	  (plus:SI (match_dup 1)(match_dup 2)))]
  ""
  "@
   add\t%0, %2 wc
   sub\t%0, #%n2 wc"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)
(define_insn "*addsi3_set_carry2"
  [(set (reg:CC_C CC_REG)
        (compare:CC_C
          (plus:SI (match_operand:SI 1 "propeller_dst_operand" "%0,0")
                   (match_operand:SI 2 "propeller_add_operand"  "rCI,N"))
          (match_dup 2)))
  (set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	  (plus:SI (match_dup 1)(match_dup 2)))]
  ""
  "@
   add\t%0, %2 wc
   sub\t%0, #%n2 wc"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)

;; versions which just test the flags
(define_insn "*addsi3_set_carry1only"
  [(set (reg:CC_C CC_REG)
        (compare:CC_C
          (plus:SI (match_operand:SI 0 "propeller_dst_operand" "rC,rC")
                   (match_operand:SI 1 "propeller_add_operand"  "rCI,N"))
          (match_dup 0)))]
  ""
  "@
   add\t%0, %1 wc,nr
   sub\t%0, #%n1 wc,nr"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)
(define_insn "*addsi3_set_carry2only"
  [(set (reg:CC_C CC_REG)
        (compare:CC_C
          (plus:SI (match_operand:SI 0 "propeller_dst_operand" "rC,rC")
                   (match_operand:SI 1 "propeller_add_operand"  "rCI,N"))
          (match_dup 1)))]
  ""
  "@
   add\t%0, %1 wc,nr
   sub\t%0, #%n1 wc,nr"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)

;; subtract and set flags

(define_insn "*subsi3_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
          (minus:SI (match_operand:SI 1 "propeller_dst_operand" "0")
                    (match_operand:SI 2 "propeller_src_operand" "rCI"))
          (const_int 0)))
  (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	  (minus:SI (match_dup 1)(match_dup 2)))]
  ""
  "sub\t%0, %2 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)

(define_insn "*subsi3_compare"
  [(set (reg:CC CC_REG)
        (compare:CC (match_operand:SI 1 "propeller_dst_operand" "0")
                    (match_operand:SI 2 "propeller_src_operand" "rCI")))
  (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	  (minus:SI (match_dup 1)(match_dup 2)))]
  ""
  "subs\t%0, %2 wz,wc"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)

(define_insn "*subsi3_compare_unsigned"
  [(set (reg:CCUNS CC_REG)
        (compare:CCUNS (match_operand:SI 1 "propeller_dst_operand" "0")
                       (match_operand:SI 2 "propeller_src_operand" "rCI")))
  (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	  (minus:SI (match_dup 1)(match_dup 2)))]
  ""
  "sub\t%0, %2 wz,wc"
  [(set_attr "conds" "set")(set_attr "predicable" "yes")]
)

(define_insn "*subsi3_compare_carry"
  [(set (reg:CC_C CC_REG)
        (compare:CC_C
          (match_operand:SI 1 "propeller_dst_operand" "0")
          (minus:SI (match_dup 1)
                    (match_operand:SI 2 "propeller_src_operand" "rCI"))))
  (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	  (minus:SI (match_dup 1)(match_dup 2)))]
  ""
  "sub\t%0, %2 wc"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)


;;
;; special cases of add and sub
;;
;; set x:= x+abs(y)
;;
(define_insn "*addabs"
  [(set (match_operand:SI         0 "propeller_dst_operand" "=rC")
          (plus:SI
	    (abs:SI (match_operand:SI 1 "propeller_src_operand" "rCI"))
	    	    (match_operand:SI 2 "propeller_dst_operand" "0")
    ))]
  ""
  "addabs\t%0, %1"
  [(set_attr "predicable" "yes")]
)

(define_insn "*subabs"
  [(set (match_operand:SI         0 "propeller_dst_operand" "=rC")
          (minus:SI
	    	    (match_operand:SI 1 "propeller_dst_operand" "0")
	    (abs:SI (match_operand:SI 2 "propeller_src_operand" "rCI"))
    ))]
  ""
  "subabs\t%0, %2"
  [(set_attr "predicable" "yes")]
)

(define_insn "*cmpsub"
  [(set (reg:CCUNS CC_REG)
        (compare:CCUNS (match_operand:SI 1 "propeller_dst_operand" "0")
	               (match_operand:SI 2 "propeller_src_operand" "rCI")))
   (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (if_then_else:SI
	   (gtu (reg:CCUNS CC_REG)(const_int 0))
           (minus:SI (match_dup 1)(match_dup 2))
           (match_dup 1)))]
  ""
  "cmpsub\t%0,%2 wz,wc"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

;;
;; add with carry
;;
;; These insns work because they compare the result with one of
;; the operands, and we know that the use of the condition code is
;; either GEU or LTU, so we can use the carry flag from the addition
;; instead of doing the compare a second time.

(define_insn "*addsi3_carryin1"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(plus:SI (plus:SI
		   (ltu:SI (reg:CC_C CC_REG)(const_int 0))
		   (match_operand:SI 2 "propeller_src_operand" "rCI"))
		 (match_operand:SI 1 "propeller_dst_operand" "%0")))]
  ""
  "addx\t%0, %2"
  [(set_attr "conds" "use")
   (set_attr "predicable" "yes")
  ]
)

(define_insn "*addsi3_carryin2"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(plus:SI (ltu:SI (reg:CC_C CC_REG)(const_int 0))
		 (match_operand:SI 1 "propeller_dst_operand" "0")))]
  ""
  "addx\t%0, #0"
  [(set_attr "conds" "use")
   (set_attr "predicable" "yes")
  ]
)

;;
;; subtract with carry
;;
(define_insn "*subsi3_carryin1"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (minus:SI
	  (minus:SI (match_operand:SI 1 "propeller_dst_operand" "0")
	            (match_operand:SI 2 "propeller_src_operand" "rCI"))
          (ltu:SI (reg:CC_C CC_REG)(const_int 0))))]
  ""
  "subx\t%0, %2"
  [(set_attr "conds" "use")
   (set_attr "predicable" "yes")
  ]
)

;; combine sometimes produces this somewhat baroque version of the above
(define_insn "*subsi3_carryin2"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (minus:SI
	  (minus:SI (match_operand:SI 1 "propeller_dst_operand" "0")
	            (if_then_else:SI (ltu:SI (reg:CC_C CC_REG)(const_int 0))
	  	                     (const_int 1)
				      (const_int 0)))

	  (match_operand:SI 2 "propeller_src_operand" "rCI")))
   ]
  ""
  "subx\t%0, %2"
  [(set_attr "conds" "use")
   (set_attr "predicable" "yes")
  ]
)

;; 64 bit addition is done correctly with the default pattern
;; for subtraction though the default pattern checks (x-y) > x,
;; whereas we really want to check for x < y
;;
;; temporarily disabled here
;(define_insn_and_split "subdi3"
;  [(set (match_operand:DI 0 "propeller_dst_operand" "=&rC")
;        (minus:DI (match_operand:DI 1 "propeller_dst_operand" "0")
;                  (match_operand:DI 2 "propeller_dst_operand" "rC")))]
;  ""
;  "#"
;  "&& reload_completed"
;  [(parallel
;       [(set (reg:CCUNS CC_REG)
;	     (compare:CCUNS (match_dup 0) (match_dup 1)))
;	(set (match_dup 0) (minus:SI (match_dup 0) (match_dup 1)))])
;   (set (match_dup 3)
;            (minus:SI 
;		  (minus:SI (match_dup 3) (match_dup 4))
;                  (ltu:SI (reg:CC_C CC_REG) (const_int 0))))
;  ]
;  {
;    operands[3] = gen_highpart (SImode, operands[0]);
;    operands[4] = gen_highpart_mode (SImode, DImode, operands[2]);
;    operands[0] = gen_lowpart (SImode, operands[0]);
;    operands[1] = gen_lowpart (SImode, operands[2]);
;  }
;  [(set_attr "length" "8")]
;)

;; -------------------------------------------------------------------------
;; Unary arithmetic instructions
;; -------------------------------------------------------------------------

(define_insn "abssi2"
  [(set (match_operand:SI         0 "propeller_dst_operand" "=rC")
	(abs:SI (match_operand:SI 1 "propeller_src_operand" "rCI")))]
  ""
  "abs\t%0, %1"
  [(set_attr "predicable" "yes")]
)

(define_insn "negsi2"
  [(set (match_operand:SI         0 "propeller_dst_operand" "=rC")
	(neg:SI (match_operand:SI 1 "propeller_src_operand" "rCI")))]
  ""
  "neg\t%0, %1"
  [(set_attr "predicable" "yes")]
)

(define_insn "*absnegsi2"
  [(set (match_operand:SI         0 "propeller_dst_operand" "=rC")
	(neg:SI (abs:SI (match_operand:SI 1 "propeller_src_operand" "rCI"))))]
  ""
  "absneg\t%0, %1"
  [(set_attr "predicable" "yes")]
)

(define_insn "*<oneop:code>si2_comparesrc"
  [
    (set (reg:CC CC_REG)
         (compare:CC 
	    (match_operand:SI 1 "propeller_src_operand" "rCI")
	    (const_int 0)))
    (set (match_operand:SI         0 "propeller_dst_operand" "=rC")
	     (oneop:SI (match_dup 1)))
  ]
  ""
  "<opcode>\t%0, %1 wz, wc"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

(define_insn "*<oneop:code>si2_compare0"
  [
    (set (reg:CC_Z CC_REG)
         (compare:CC_Z 
	    (oneop:SI (match_operand:SI 1 "propeller_src_operand" "rCI"))
	    (const_int 0)))
    (set (match_operand:SI         0 "propeller_dst_operand" "=rC")
	     (oneop:SI (match_dup 1)))
  ]
  ""
  "<opcode>\t%0, %1 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

;;
;; the instruction set doesn't actually have a NOT instruction, so synthesize
;; it from XOR; we'll just put a handy 0xFFFFFFFF somewhere in cog memory
;;
;;
(define_insn "one_cmplsi2"
  [ (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
         (not:SI (match_operand:SI 1 "propeller_src_operand" "0")))]
  ""
{
  propeller_need_maskffffffff = true; /* make sure we generate the FFFFFFFF */
  return "xor\t%0,__MASK_FFFFFFFF";
})

(define_insn "*one_cmplsi2_compare0"
  [ (set (reg:CC_Z CC_REG)
         (compare:CC_Z
           (not:SI (match_operand:SI 1 "propeller_src_operand" "0"))
	   (const_int 0)))
    (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
         (not:SI (match_dup 1)))]
  ""
{
  propeller_need_maskffffffff = true; /* make sure we generate the FFFFFFFF */
  return "xor\t%0,__MASK_FFFFFFFF";
})

;; -------------------------------------------------------------------------
;; Logical operators
;; -------------------------------------------------------------------------

;; and is a little bit odd because the "andn" instruction gives us an
;; opportunity to optimize some constants


(define_insn "*andnotsi3"
  [(set (match_operand:SI                 0 "propeller_dst_operand" "=rC")
	(and:SI (not:SI (match_operand:SI 1 "propeller_src_operand" " rCI"))
		(match_operand:SI         2 "propeller_dst_operand" " 0")))]
  ""
  "andn\t%0, %1"
  [(set_attr "predicable" "yes")]
)

(define_insn "andsi3"
  [(set (match_operand:SI         0 "propeller_dst_operand" "=rC,rC")
	(and:SI (match_operand:SI 1 "propeller_dst_operand" "%0,0")
		(match_operand:SI 2 "propeller_and_operand" " rCI,M")))]
  ""
  "@
   and\t%0, %2
   andn\t%0, %M2"
  [(set_attr "predicable" "yes")]
)

;; versions that check against 0
(define_insn "*andsi3_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (and:SI
	    (match_operand:SI 1 "propeller_dst_operand" "%0,0")
            (match_operand:SI 2 "propeller_and_operand" "rCI,M"))
          (const_int 0)))
   (set (match_operand:SI     0 "propeller_dst_operand" "=rC,rC")
        (and:SI (match_dup 1)(match_dup 2)))
   ]
  ""
  "@
   and\t%0,%2 wz
   andn\t%0,%M2 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)
(define_insn "*andsi3_compare0_only"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (and:SI
	    (match_operand:SI 0 "propeller_dst_operand" "rC,rC")
            (match_operand:SI 1 "propeller_and_operand" "rCI,M"))
          (const_int 0)))
   ]
  ""
  "@
   test\t%0,%1 wz
   andn\t%0,%M1 wz,nr"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

;;
;; slightly funky version that sets the carry bit for parity
;; if C is set that usually means "ltu", so we do a compare 0<parity
;; rather than parity<0
(define_insn "*andsi3_compare0_parity"
  [(set (reg:CC_C CC_REG)
        (compare:CC_C
	    (const_int 0)
	    (parity:SI
	      (and:SI
	        (match_operand:SI 0 "propeller_dst_operand" "rC,rC")
              	(match_operand:SI 1 "propeller_and_operand" "rCI,M")))))
   ]
  ""
  "@
   test\t%0,%1 wc
   andn\t%0,%M1 wc,nr"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

;; sometimes in combine "ands" are converted to "zero extract"
;; this seems to happen for contiguous bit fields in the low
;; bits (so operand 2 is 0) or for single bits (so operand 1 is 1)

(define_insn "*andsi3_zext_compare0_only"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (zero_extract:SI
	    (match_operand:SI 0 "propeller_dst_operand" "rC")
            (match_operand:SI 1 "immediate_1_9" "i")
	    (const_int 0))
          (const_int 0)))
   ]
  ""
  "test\t%0,%m1 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

(define_insn "*andsi3_zext_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (zero_extract:SI
	    (match_operand:SI 1 "propeller_dst_operand" "0")
            (match_operand:SI 2 "immediate_1_9" "i")
            (const_int 0))
          (const_int 0)))
   (set (match_operand:SI     0 "propeller_dst_operand" "=rC")
        (zero_extract:SI (match_dup 1)(match_dup 2)(const_int 0)))
   ]
  ""
  "and\t%0,%m2 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

(define_insn "*andsi3_zextbit_compare0_only"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (zero_extract:SI
	    (match_operand:SI 0 "propeller_dst_operand" "rC")
	    (const_int 1)
            (match_operand:SI 1 "immediate_0_8" "i"))
          (const_int 0)))
   ]
  ""
  "test\t%0,%S1 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

(define_insn "*andsi3_zextbit_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (zero_extract:SI
	    (match_operand:SI 1 "propeller_dst_operand" "0")
	    (const_int 1)
            (match_operand:SI 2 "immediate_0_8" "i"))
          (const_int 0)))
   (set (match_operand:SI     0 "propeller_dst_operand" "=rC")
        (zero_extract:SI (match_dup 1)(const_int 1)(match_dup 2)))
   ]
  ""
{
   return "and\t%0,%S2 wz";
}
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

; xor and ior are very regular, we can use the orop iterator for them

(define_insn "<orop:code>si3"
  [(set (match_operand:SI             0 "propeller_dst_operand" "=rC")
	(orop:SI    (match_operand:SI 1 "propeller_dst_operand" "%0")
	            (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "<opcode>\t%0, %2"
  [(set_attr "predicable" "yes")]
)

(define_insn "*<orop:code>si3_compare0_only"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (orop:SI
	    (match_operand:SI 0 "propeller_dst_operand" "rC")
            (match_operand:SI 1 "propeller_src_operand" "rCI"))
          (const_int 0)))
   ]
  ""
  "<opcode>\t%0, %1 wz,nr"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

(define_insn "*<orop:code>si3_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (orop:SI
	    (match_operand:SI 1 "propeller_dst_operand" "%0")
            (match_operand:SI 2 "propeller_src_operand" "rCI"))
          (const_int 0)))
   (set (match_operand:SI     0 "propeller_dst_operand" "=rC")
        (orop:SI (match_dup 1)(match_dup 2)))
  ]
  ""
  "<opcode>\t%0, %2 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

;; -------------------------------------------------------------------------
;; single bit insert, and multiple bit inserts
;; operand 1 is the width, operand 2 the starting position
;; -------------------------------------------------------------------------
(define_insn "insv_movs"
  [(set (zero_extract:SI (match_operand:SI 0 "propeller_dst_operand" "+rC")
                         (match_operand:SI 1 "const_int_operand" "i")
                         (match_operand:SI 2 "const_int_operand" "i"))
        (match_operand:SI 3 "propeller_src_operand" "rCI"))]
  "INTVAL (operands[1]) == 9 && INTVAL (operands[2]) == 0"
  "movs\\t%0, %3"
  [(set_attr "predicable" "yes")]
)
(define_insn "insv_movd"
  [(set (zero_extract:SI (match_operand:SI 0 "propeller_dst_operand" "+rC")
                         (match_operand:SI 1 "const_int_operand" "i")
                         (match_operand:SI 2 "const_int_operand" "i"))
        (match_operand:SI 3 "propeller_src_operand" "rCI"))]
  "INTVAL (operands[1]) == 9 && INTVAL (operands[2]) == 9"
  "movd\\t%0, %3"
  [(set_attr "predicable" "yes")]
)
(define_insn "insv_movi"
  [(set (zero_extract:SI (match_operand:SI 0 "propeller_dst_operand" "+rC")
                         (match_operand:SI 1 "const_int_operand" "i")
                         (match_operand:SI 2 "const_int_operand" "i"))
        (match_operand:SI 3 "propeller_src_operand" "rCI"))]
  "INTVAL (operands[1]) == 9 && INTVAL (operands[2]) == 23"
  "movi\\t%0, %3"
  [(set_attr "predicable" "yes")]
)

(define_expand "insv"
  [(set (zero_extract:SI (match_operand:SI 0 "propeller_dst_operand" "")
                         (match_operand:SI 1 "const_int_operand" "")
			 (match_operand:SI 2 "const_int_operand" ""))
        (match_operand:SI 3 "propeller_src_operand" ""))]
  ""
{
  int start_bit = INTVAL (operands[2]);
  int width = INTVAL (operands[1]);

  if (width == 9) {
    if (start_bit == 0) {
      emit_insn (gen_insv_movs (operands[0], operands[1], operands[2], operands[3]));
      DONE;
    } else if (start_bit == 9) {
      emit_insn (gen_insv_movd (operands[0], operands[1], operands[2], operands[3]));
      DONE;
    } else if (start_bit == 23) {
      emit_insn (gen_insv_movi (operands[0], operands[1], operands[2], operands[3]));
      DONE;
    }
  }
  FAIL;
})


;;
;; -------------------------------------------------------------------------
;; Shifters
;; -------------------------------------------------------------------------

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(ashift:SI (match_operand:SI 1 "propeller_dst_operand" "0")
		   (match_operand:SI 2 "propeller_src_operand" "rCI")))]
  ""
  "shl\t%0, %2"
  [(set_attr "predicable" "yes")]
)

(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(ashiftrt:SI (match_operand:SI 1 "propeller_dst_operand" "0")
		     (match_operand:SI 2 "propeller_src_operand" "rCI")))]
  ""
  "sar\t%0, %2"
  [(set_attr "predicable" "yes")]
)

(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(lshiftrt:SI (match_operand:SI 1 "propeller_dst_operand" "0")
		     (match_operand:SI 2 "propeller_src_operand" "rCI")))]
  ""
  "shr\t%0, %2"
  [(set_attr "predicable" "yes")]
)

(define_insn "rotlsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(rotate:SI (match_operand:SI 1 "propeller_dst_operand" "0")
		   (match_operand:SI 2 "propeller_src_operand" "rCI")))]
  ""
  "rol\t%0, %2"
  [(set_attr "predicable" "yes")]
)

(define_insn "rotrsi3"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(rotatert:SI (match_operand:SI 1 "propeller_dst_operand" "0")
		     (match_operand:SI 2 "propeller_src_operand" "rCI")))]
  ""
  "ror\t%0, %2"
  [(set_attr "predicable" "yes")]
)

;; patterns to compare with 0
(define_insn "*<shiftop:code>si3_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (shiftop:SI
	    (match_operand:SI 1 "propeller_dst_operand" "0")
            (match_operand:SI 2 "propeller_src_operand" "rCI"))
          (const_int 0)))
   (set (match_operand:SI     0 "propeller_dst_operand" "=rC")
        (shiftop:SI (match_dup 1)(match_dup 2)))
  ]
  ""
  "<opcode>\t%0, %2 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

(define_insn "*<shiftop:code>si3_compare0_only"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (shiftop:SI
	    (match_operand:SI 0 "propeller_dst_operand" "rC")
            (match_operand:SI 1 "propeller_src_operand" "rCI"))
          (const_int 0)))
   ]
  ""
  "<opcode>\t%0, %1 wz,nr"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

;;
;; rotate right with carry
;;
(define_insn "*rcr"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (ior:SI
	   (lshiftrt:SI (match_operand:SI 1 "propeller_dst_operand" "0")
                        (const_int 1))
           (ashift:SI   (ltu:SI (reg:CC_C CC_REG)(const_int 0))
                        (const_int 31))))
   ]
   ""
   "rcr\t%0,#1"
  [(set_attr "conds" "use")
   (set_attr "predicable" "yes")
  ]
)

(define_insn "*rcl"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (ior:SI
	   (ashift:SI (match_operand:SI 1 "propeller_dst_operand" "0")
                        (const_int 1))
           (ltu:SI (reg:CC_C CC_REG)(const_int 0))))
   ]
   ""
   "rcl\t%0,#1"
  [(set_attr "conds" "use")
   (set_attr "predicable" "yes")
  ]
)

;; -------------------------------------------------------------------------
;; special push/pop instructions
;; -------------------------------------------------------------------------

;; push registers on the stack
;; operand 0 is the size of the stack adjustment;
;; operand 1 is a vector of registers to push

(define_insn "stack_pushm"
  [(match_parallel 1 "propeller_store_multiple_vector"
     [(set (reg:SI SP_REG)
	   (minus:SI (reg:SI SP_REG)
		     (match_operand:SI 0 "const_int_operand" "n")))])]
  "TARGET_LMM && reload_completed"
  {
    propeller_emit_stack_pushm (operands);
    return "";
  }
  [(set_attr "length" "8")
   (set_attr "type" "multi")]
)

(define_insn "stack_popm"
  [(match_parallel 1 "propeller_load_multiple_vector"
     [(set (reg:SI SP_REG)
	   (plus:SI (reg:SI SP_REG)
		    (match_operand:SI 0 "const_int_operand" "n")))])]
  "TARGET_LMM && reload_completed"
  {
    propeller_emit_stack_popm (operands, 0);
    return "";
  }
  [(set_attr "length" "8")
   (set_attr "type" "multi")]
)

;; -------------------------------------------------------------------------
;; Move instructions
;; -------------------------------------------------------------------------

;; SImode

(define_expand "movsi"
   [(set (match_operand:SI 0 "nonimmediate_operand" "")
 	(match_operand:SI 1 "general_operand" ""))]
   ""
{
  if (!propeller_cogreg_operand (operands[0], SImode)
      && !propeller_cogreg_operand (operands[1], SImode))
    {
      operands[1] = force_reg (SImode, operands[1]);
    }
})

(define_insn "*movsi_imm_cmm"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (match_operand:SI 1 "propeller_cmm_const16" "i"))]
  "TARGET_CMM"
  "mviw\t%0,#%c1"
  [(set_attr "length" "8")
  ]
)

(define_insn "*movsi_imm_lmm"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (match_operand:SI 1 "propeller_big_const" "i"))]
  "TARGET_LMM"
  "mvi\t%0,#%c1"
  [(set_attr "length" "8")
  ]
)

(define_insn "*movsi_imm_fcache"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (unspec:SI [(label_ref (match_operand 1 "" ""))
	            (label_ref (match_operand 2 "" ""))]
         UNSPEC_FCACHE_LABEL_REF))
  ]
  "TARGET_LMM"
  "mov\t%0,__LMM_FCACHE_START+(%l1-%l2)"
  [(set_attr "length" "4")
  ]
)


(define_insn "*movsi_xmm"
  [(set (match_operand:SI 0 "nonimmediate_operand"          "=rC,rC,r,S,r,Q")
	(match_operand:SI 1 "general_operand"               "rCI,N,S,r,Q,r"))]
  "TARGET_XMM"
  "@
   mov\t%0, %1
   neg\t%0, #%n1
   rdlong\t%0, %1
   wrlong\t%1, %0
   xmmio\trdlong,%0,%1
   xmmio\twrlong,%1,%0"
   [(set_attr "type" "core,core,hub,hub,multi,multi")
    (set_attr "length" "4,4,4,4,8,8")
    (set_attr "predicable" "no")
   ]
)

(define_insn "*movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand"          "=rC,rC,rC,rC,Q")
	(match_operand:SI 1 "general_operand"               "rCI,B,N,Q,rC"))]
  "!TARGET_XMM"
  "@
   mov\t%0, %1
   mova\t%0, #%1
   neg\t%0, #%n1
   rdlong\t%0, %1
   wrlong\t%1, %0"
   [(set_attr "type" "core,core,core,hub,hub")
    (set_attr "predicable" "yes")]
)

(define_insn "*movsi_compare_signed"
  [(set (reg:CC CC_REG)
	(compare:CC (match_operand:SI 1 "propeller_src_operand" "rCI")
		    (const_int 0)))
   (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(match_dup 1))]
  ""
  "mov\t%0,%1 wz,wc"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

(define_insn "*movsi_comparesign_flip"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(match_operand:SI 1 "propeller_src_operand" "rCI"))
   (set (reg:CC CC_REG)
	(compare:CC (match_dup 1)
		    (const_int 0)))]
  ""
  "mov\t%0,%1 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)

;; compare and set patterns
(define_insn "*movsi_compare0"
  [(set (reg:CC_Z CC_REG)
	(compare:CC_Z (match_operand:SI 1 "propeller_src_operand" "rCI")
		      (const_int 0)))
   (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(match_dup 1))]
  ""
  "mov\t%0,%1 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)
(define_insn "*movsi_compare0_flip"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(match_operand:SI 1 "propeller_src_operand" "rCI"))
   (set (reg:CC_Z CC_REG)
	(compare:CC_Z (match_dup 1)
		      (const_int 0)))]
  ""
  "mov\t%0,%1 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)
(define_insn "*movsi_compare0b"
  [(set (reg:CC_Z CC_REG)
	(compare:CC_Z (match_operand:SI 0 "propeller_dst_operand" "=rC")
		      (const_int 0)))
   (set (match_dup 0)
	(match_operand:SI 1 "propeller_src_operand" "rCI"))]
  ""
  "mov\t%0,%1 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)
(define_insn "*movsi_compare0_flipb"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
	(match_operand:SI 1 "propeller_src_operand" "rCI"))
   (set (reg:CC_Z CC_REG)
	(compare:CC_Z (match_dup 0)
		      (const_int 0)))]
  ""
  "mov\t%0,%1 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")]
)


(define_expand "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "")
	(match_operand:HI 1 "general_operand" ""))]
  ""
  "
{
  /* If this is a store, force the value into a register.  */
  if (!propeller_cogreg_operand (operands[0], HImode)
      && !propeller_cogreg_operand (operands[1], HImode))
    operands[1] = force_reg (HImode, operands[1]);
}")

(define_insn "*movhi_imm_fcache"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (unspec:HI [(label_ref (match_operand 1 "" ""))
	            (label_ref (match_operand 2 "" ""))]
         UNSPEC_FCACHE_LABEL_REF))
  ]
  "TARGET_LMM"
  "mov\t%0,__LMM_FCACHE_START+(%l1-%l2)"
  [(set_attr "length" "4")
  ]
)

(define_insn "*movhi_cmm"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "propeller_cmm_const16" "i"))]
  "TARGET_CMM"
  "mviw\t%0,#%c1"
  [(set_attr "length" "8")
  ]
)
(define_insn "*movhi_lmm"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "propeller_big_const" "i"))]
  "TARGET_LMM"
  "mvi\t%0,#%c1"
  [(set_attr "length" "8")
  ]
)

(define_insn "*movhi_xmm"
  [(set (match_operand:HI 0 "nonimmediate_operand"          "=rC,rC,rC,S,r,Q")
	(match_operand:HI 1 "general_operand"               "rCI,N,S,rC,Q,r"))]
  "TARGET_XMM"
  "@
   mov\t%0, %1
   neg\t%0, #%n1
   rdword\t%0, %1
   wrword\t%1, %0
   xmmio\trdword,%0,%1
   xmmio\twrword,%1,%0"
   [(set_attr "type" "core,core,hub,hub,multi,multi")
    (set_attr "length" "4,4,4,4,8,8")
    (set_attr "predicable" "no")
   ]
)

(define_insn "*movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand"          "=rC,rC,rC,Q")
	(match_operand:HI 1 "general_operand" "rCI,N,Q,rC"))]
  "!TARGET_XMM"
  "@
   mov\t%0, %1
   neg\t%0, #%n1
   rdword\t%0, %1
   wrword\t%1, %0"
  [(set_attr "type" "core,core,hub,hub")
   (set_attr "predicable" "yes")]
)

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand" "")
	(match_operand:QI 1 "nonimmediate_operand" ""))]
  ""
  "
{
  /* If this is a store, force the value into a register.  */
  if (!propeller_cogreg_operand (operands[0], QImode)
      && !propeller_cogreg_operand (operands[1], QImode))
    operands[1] = force_reg (QImode, operands[1]);
}")

(define_insn "*movqi_xmm"
  [(set (match_operand:QI 0 "nonimmediate_operand"          "=rC,rC,rC,S,r,Q")
	(match_operand:QI 1 "general_operand"               "rCI,N,S,rC,Q,r"))]
  "TARGET_XMM"
  "@
   mov\t%0, %1
   neg\t%0, #%n1
   rdbyte\t%0, %1
   wrbyte\t%1, %0
   xmmio\trdbyte,%0,%1
   xmmio\twrbyte,%1,%0"
   [(set_attr "type" "core,core,hub,hub,multi,multi")
    (set_attr "length" "4,4,4,4,8,8")
    (set_attr "predicable" "no")
   ]
)

(define_insn "*movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand"   "=rC,rC,rC,Q")
	(match_operand:QI 1 "general_operand"         "rCI,N,Q,rC"))]
  "!TARGET_XMM"
  "@
   mov\t%0, %1
   neg\t%0, #%n1
   rdbyte\t%0, %1
   wrbyte\t%1, %0"
  [(set_attr "type" "core,core,hub,hub")
   (set_attr "predicable" "yes")]
)

;; -------------------------------------------------------------------------
;; extending qi and hi to si
;; the default gcc way of extending (using shifts) is fine for
;; extending hi to si and for sign extensions, but for zero extension
;; "and" is better
;; -------------------------------------------------------------------------

;; the h constraint says that alternative cannot be in cog memory
(define_insn "*zero_extendhisi2_xmm"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,r,r")
	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0,S,h")))]
  "TARGET_XMM"
{
  switch(which_alternative) {
    case 0:
      propeller_need_mask0000ffff = true;
      return "and\\t%0,__MASK_0000FFFF";
    case 1:
      return "rdword\\t%0,%1";
    case 2:
      return "xmmio\\trdword,%0,%1";
    default:
      gcc_unreachable ();
  }
}
  [(set_attr "type" "core,hub,multi")
   (set_attr "length" "4,4,8")
  ]
)

(define_insn "*zero_extendhisi2_noxmm"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0,h")))]
  "!TARGET_XMM"
{
  switch(which_alternative) {
    case 0:
      propeller_need_mask0000ffff = true;
      return "and\\t%0,__MASK_0000FFFF";
    case 1:
      return "rdword\\t%0, %1";
    default:
      gcc_unreachable ();
  }
}
  [(set_attr "type" "core,hub")]
)

(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0,h")))]
  ""
  ""
)

(define_insn "*zero_extendqisi2_xmm"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,r,r")
	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "0,S,h")))]
  "TARGET_XMM"
{
  switch(which_alternative) {
    case 0:
      return "and\\t%0,#255";
    case 1:
      return "rdbyte\\t%0,%1";
    case 2:
      return "xmmio\\trdbyte,%0,%1";
    default:
      gcc_unreachable ();
  }
}
  [(set_attr "type" "core,hub,multi")
   (set_attr "length" "4,4,8")
  ]
)

(define_insn "*zero_extendqisi2_noxmm"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "0,h")))]
  "!TARGET_XMM"
{
  switch(which_alternative) {
    case 0:
      return "and\\t%0,#255";
    case 1:
      return "rdbyte\\t%0, %1";
    default:
      gcc_unreachable ();
  }
}
  [(set_attr "type" "core,hub")]
)

(define_expand "zero_extendqisi2"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "0,h")))]
  ""
  ""
)

;; the "h" constraint says the operand cannot be in cog memory
(define_insn "*zero_extendqisi2_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "0,h"))
	  (const_int 0)))
   (set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC")
        (zero_extend:SI (match_dup 1)))]
  "!TARGET_XMM"
{
  switch(which_alternative) {
    case 0:
      return "and\\t%0,#255 wz";
    case 1:
      return "rdbyte\\t%0, %1 wz";
    default:
      gcc_unreachable ();
  }
}
  [(set_attr "type" "core,hub")]
)

;; -------------------------------------------------------------------------
;; multiply
;; on propeller 1 multiply has to be implemented in software; we do this
;; by calling in to a library function which takes r0,r1 and returns r0
;; the function is allowed to clobber r1, r2, and the condition codes
;; -------------------------------------------------------------------------

;; We must use a pseudo-reg forced to reg 0 in the SET_DEST rather than
;; hard register 0.  If we used hard register 0, then the next instruction
;; would be a move from hard register 0 to a pseudo-reg.  If the pseudo-reg
;; gets allocated to a stack slot that needs its address reloaded, then
;; there is nothing to prevent reload from using r0 to reload the address.
;; This reload would clobber the value in r0 we are trying to store.
;; If we let reload allocate r0, then this problem can never happen.

(define_insn "*prop_mulsi3"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (mult:SI (reg:SI 0)(reg:SI 1)))
   (clobber (reg:SI 1))
   (clobber (reg:CC CC_REG))
  ]
""
{
  propeller_need_mulsi = true;
  return TARGET_CMM ? "lmul" : "call\t#__MULSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")
 ]
)

(define_expand "mulsi3"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (set (reg:SI 1)(match_operand:SI 2 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(mult:SI (reg:SI 0)(reg:SI 1)))
     (clobber (reg:SI 1))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
  ]
""
"")

;; -------------------------------------------------------------------------
;; divide
;; on propeller 1 divide has to be implemented in software; we do this
;; by calling in to a library function which takes r0,r1 and returns
;; r0/r1 in r0 and r0%r1 in r1
;; -------------------------------------------------------------------------

(define_insn "*prop_udivmodsi4"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (udiv:SI (reg:SI 0)(reg:SI 1)))
   (set (match_operand:SI 1 "register_operand" "=y")
        (umod:SI (reg:SI 0)(reg:SI 1)))
   (clobber (reg:CC CC_REG))
  ]
""
{
  propeller_need_udivsi = true;
  return TARGET_CMM ? "ludiv" : "call\t#__UDIVSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")
 ]
)

(define_expand "udivmodsi4"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (set (reg:SI 1)(match_operand:SI 2 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(udiv:SI (reg:SI 0)(reg:SI 1)))
     (set (reg:SI 1)(umod:SI (reg:SI 0)(reg:SI 1)))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
   (set (match_operand:SI 3 "propeller_dst_operand" "")(reg:SI 1))
  ]
""
"")

(define_insn "*prop_divmodsi4"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (div:SI (reg:SI 0)(reg:SI 1)))
   (set (match_operand:SI 1 "register_operand" "=y")
        (mod:SI (reg:SI 0)(reg:SI 1)))
   (clobber (reg:CC CC_REG))
  ]
""
{
  propeller_need_divsi = true;
  return TARGET_CMM ? "ldiv" : "call\t#__DIVSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")
 ]
)

(define_expand "divmodsi4"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (set (reg:SI 1)(match_operand:SI 2 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(div:SI (reg:SI 0)(reg:SI 1)))
     (set (reg:SI 1)(mod:SI (reg:SI 0)(reg:SI 1)))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
   (set (match_operand:SI 3 "propeller_dst_operand" "")(reg:SI 1))
  ]
""
"")

;;
;; we have a library udivmoddi4 routine, so try to force generation of
;; a call to it
;; we do this by having a simple expander that will catch divide by 2
;;
(define_expand "udivmoddi4"
  [(set (match_operand:DI 0 "propeller_dst_operand")
        (div:DI (match_operand:DI 2 "propeller_dst_operand" "")
	        (match_operand:DI 3 "propeller_src_operand" "")))
   (set (match_operand:DI 1 "propeller_dst_operand")
        (mod:DI (match_dup 2)(match_dup 3)))
  ]
""
{
  FAIL;
}
)
;; -------------------------------------------------------------------------
;; min/max instructions
;; NOTE!! The Propeller instruction names are the reverse of what one
;; might expect: the "max X,Y" instruction does X := (X > Y) ? Y : X
;; -------------------------------------------------------------------------
(define_insn "umaxsi3"
  [(set (match_operand:SI          0 "propeller_dst_operand" "=rC")
	(umax:SI (match_operand:SI 1 "propeller_dst_operand" "%0")
		 (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "min\\t%0, %2"
  [(set_attr "predicable" "yes")]
)

(define_insn "uminsi3"
  [(set (match_operand:SI          0 "propeller_dst_operand" "=rC")
	(umin:SI (match_operand:SI 1 "propeller_dst_operand" "%0")
		 (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "max\\t%0, %2"
  [(set_attr "predicable" "yes")]
)

(define_insn "smaxsi3"
  [(set (match_operand:SI          0 "propeller_dst_operand" "=rC")
	(smax:SI (match_operand:SI 1 "propeller_dst_operand" "%0")
		 (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "mins\\t%0, %2"
  [(set_attr "predicable" "yes")]
)

(define_insn "sminsi3"
  [(set (match_operand:SI          0 "propeller_dst_operand" "=rC")
	(smin:SI (match_operand:SI 1 "propeller_dst_operand" "%0")
		 (match_operand:SI 2 "propeller_src_operand" " rCI")))]
  ""
  "maxs\\t%0, %2"
  [(set_attr "predicable" "yes")]
)

;;
;; combinations that set the condition codes
;; NOTE: for the "max A,B" instructions, the Z flag is set based
;; on whether the second operand is 0, and C is set based on
;;  A < B; similarly for min
(define_insn "*<minmaxop:code>si3_compare0"
  [(set (reg:CC_Z CC_REG)
        (compare:CC_Z
	  (match_operand:SI 2 "propeller_src_operand" "rCI")
          (const_int 0)))
   (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (minmaxop:SI 
		     (match_operand:SI 1 "propeller_dst_operand" "0")
		     (match_dup 2)))
  ]
  ""
  "<opcode>\t%0, %2 wz"
  [(set_attr "conds" "set")
   (set_attr "predicable" "yes")
  ]
)
	
;; -------------------------------------------------------------------------
;; Conditional moves and stores
;; -------------------------------------------------------------------------

;; conditional move

(define_expand "movsicc"
  [(set (match_operand:SI 0 "propeller_dst_operand" "")
	(if_then_else:SI (match_operand 1 "predicate_operator" "")
			 (match_operand:SI 2 "propeller_add_operand" "")
			 (match_operand:SI 3 "propeller_add_operand" "")))]
  ""
  "
  {
    enum rtx_code code = GET_CODE (operands[1]);
    enum machine_mode mode;
    rtx ccreg;
    rtx x = XEXP (operands[1], 0);
    rtx y = XEXP (operands[1], 1);

    ccreg = propeller_gen_compare_reg (code, x, y);
    mode = GET_MODE (ccreg);

    /* we have to actually emit the compare! */
    emit_insn (gen_rtx_SET (VOIDmode, ccreg, gen_rtx_COMPARE (mode, x, y)));
    operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);
  }"
)

;;
;; some special cases
;; we can use the "mux" instruction to set bits to 0 or 1 (and leave
;; them alone otherwise)
;; so for example muxz r0,#1 sets the low order bit if the z flag
;; is set, and leaves it alone otherwise
;;
;;
;; in general r0 = muxz(r0, mask)
;; is the same as r0 = z ? (r0 | mask) : (r0 & ~mask)
;;

(define_insn "*or_andn_<muxcond:code>"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (if_then_else:SI
	  (muxcond (reg:<muxccmode> CC_REG)(const_int 0))
	  (ior:SI (match_operand:SI 1 "propeller_dst_operand" "0")
	          (match_operand:SI 2 "propeller_src_operand" "rCI"))
	  (and:SI (not:SI (match_dup 2))
                  (match_dup 1))))]
  ""
  "mux<muxcc>\t%0,%2"
  [(set_attr "conds" "use")]
)

;; setting all bits to 1 or 0 is a special case

(define_insn "*movesi<muxcond:code>_allones"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (if_then_else:SI
	    (muxcond (reg:<muxccmode> CC_REG)(const_int 0))
            (const_int -1)
	    (const_int 0)))]
  ""
  {
    propeller_need_maskffffffff = true;
    return "mux<muxcc>\t%0,__MASK_FFFFFFFF";
  }
  [(set_attr "conds" "use")]
)

;; setting a value to 0 or N is also a special case
;; we can do this with a split: set it to 0 first, and or in the 1 if
;; appropriate
;; so r0 := (z ? N : 0)
;; becomes r0 := 0; r0 = z ? (r0 | N) : (r0 & ~N)
;;  where we know the "&~N" will have no effect

(define_insn_and_split "*movesi<muxcond:code>_one"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=&rC")
        (if_then_else:SI
	    (muxcond (reg:<muxccmode> CC_REG)(const_int 0))
            (match_operand:SI 1 "propeller_src_operand" "rCI")
	    (const_int 0)))]
  ""
  "#"
  "reload_completed"
  [(set (match_dup 0)(const_int 0))
   (set (match_dup 0)
        (if_then_else:SI
	  (muxcond (reg:<muxccmode> CC_REG)(const_int 0))
          (ior:SI (match_dup 0)(match_dup 1))
          (and:SI (not:SI (match_dup 1))(match_dup 0))))
  ]
  ""
  [(set_attr "conds" "use")
   (set_attr "length" "8")]
)


;; the general case of movsi
(define_insn "*movsicc_insn"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC,rC,rC,rC,rC,rC,rC,rC")
        (if_then_else:SI
	  (match_operator 3 "predicate_operator"
	    [(match_operand 4 "cc_register" "") (const_int 0)])
	  (match_operand:SI 1 "propeller_add_operand" "0,0,rCI,N,rCI,rCI,N,N")
	  (match_operand:SI 2 "propeller_add_operand" "rCI,N,0,0,rCI,N,rCI,N" )))]
  ""
  "@
   %P3 mov\t%0,%2
   %P3 neg\t%0,#%n2
   %p3 mov\t%0,%1
   %p3 neg\t%0,#%n1
   %p3 mov\t%0,%1\n\t%P3 mov\t%0,%2
   %p3 mov\t%0,%1\n\t%P3 neg\t%0,#%n2
   %p3 neg\t%0,#%n1\n\t%P3 mov\t%0,%2
   %p3 neg\t%0,#%n1\n\t%P3 neg\t%0,#%n2"
  [(set_attr "predicable" "no")
   (set_attr "conds" "use")
   (set_attr "length" "4,4,4,4,8,8,8,8")
   (set_attr "type" "core,core,core,core,multi,multi,multi,multi")
  ])

;;
;; cstoresi4: store 0 or nonzero in operand 0 depending on the comparison
;;            (operand 1) of operands 2 and 3
;; we do this with a simple conditional move
;;
(define_expand "cstoresi4"
  [(set (match_dup 4)
        (match_op_dup 5
         [(match_operand:SI 2 "propeller_dst_operand" "")
          (match_operand:SI 3 "propeller_src_operand" "")]))
   (set (match_operand:SI 0 "propeller_dst_operand" "")
        (if_then_else:SI
          (match_operator:SI 1 "predicate_operator"
            [(match_dup 4)(const_int 0)])
          (const_int STORE_FLAG_VALUE)
          (const_int 0)))]
  ""
{
  operands[4] = propeller_gen_compare_reg (GET_CODE (operands[1]),
                                      operands[2], operands[3]);
  operands[5] = gen_rtx_fmt_ee (COMPARE,
                                GET_MODE (operands[4]),
                                operands[2], operands[3]);
}
)
         
;; -------------------------------------------------------------------------
;; Compare instructions
;; -------------------------------------------------------------------------


(define_insn "compare_unsigned"
  [(set (reg:CCUNS CC_REG)
	(compare:CCUNS
	 (match_operand:SI 0 "propeller_dst_operand" "rC")
	 (match_operand:SI 1 "propeller_src_operand"	"rCI")))]
  ""
  "cmp\t%0, %1 wz,wc"
  [(set_attr "conds" "set")]
)

(define_insn "compare_zero"
  [(set (reg:CC_Z CC_REG)
	(compare:CC_Z
	 (match_operand:SI 0 "propeller_dst_operand" "rC")
	 (match_operand:SI 1 "propeller_src_operand"	"rCI")))]
  ""
  "cmps\t%0, %1 wz,wc"
  [(set_attr "conds" "set")]
)

;;
;; we set both Z and C flags to allow the instruction compresser to
;; match this, but we only need C
;;
(define_insn "compare_carryonly"
  [(set (reg:CC_C CC_REG)
	(compare:CC_C
	 (match_operand:SI 0 "propeller_dst_operand" "rC")
	 (match_operand:SI 1 "propeller_src_operand"	"rCI")))]
  ""
  "cmp\t%0, %1 wz,wc"
  [(set_attr "conds" "set")]
)

(define_insn "compare_signed"
  [(set (reg:CC CC_REG)
	(compare:CC
	 (match_operand:SI 0 "propeller_dst_operand" "rC")
	 (match_operand:SI 1 "propeller_src_operand"	"rCI")))]
  ""
  "cmps\t%0, %1 wz,wc"
  [(set_attr "conds" "set")]
)


;; -------------------------------------------------------------------------
;; Branch instructions
;; -------------------------------------------------------------------------

(define_expand "cbranchsi4"
  [(set (match_dup 4)
        (match_op_dup 5
         [(match_operand:SI 1 "propeller_dst_operand" "")
          (match_operand:SI 2 "propeller_src_operand" "")]))
   (set (pc)
        (if_then_else
              (match_operator 0 "ordered_comparison_operator"
               [(match_dup 4)
                (const_int 0)])
              (label_ref (match_operand 3 "" ""))
              (pc)))]
  ""
  "
{
  operands[4] = propeller_gen_compare_reg (GET_CODE (operands[0]),
                                      operands[1], operands[2]);
  operands[5] = gen_rtx_fmt_ee (COMPARE,
                                GET_MODE (operands[4]),
                                operands[1], operands[2]);
}")

(define_insn "*condbranch"
  [(set (pc)
	(if_then_else (match_operator 1 "ordered_comparison_operator"
	                [(reg CC_REG) (const_int 0)])
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  "!TARGET_LMM"
{
  return "%p1\tjmp\t#%l0";
}
[(set_attr "conds" "use")
]
)

(define_insn "*condbranch_reverse"
  [(set (pc)
	(if_then_else (match_operator 1 "ordered_comparison_operator"
	                 [(reg CC_REG) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 0 "" ""))
        ))]	      
  "!TARGET_LMM"
{
  return "%P1\tjmp\t#%l0";
}
[(set_attr "conds" "use")
]
)

(define_insn "*condbranch_cmm"
  [(set (pc)
	(if_then_else (match_operator 1 "ordered_comparison_operator"
	                [(reg CC_REG) (const_int 0)])
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  "TARGET_CMM"
{
  return (get_attr_length (insn) == 2) ?
               "%p1\tbrs\t#%l0" :
	       "%p1\tbrw\t#%l0";
}
[(set_attr "conds" "use")
 (set (attr "length")
      (if_then_else 
          (and (ge (minus (match_dup 0)(pc)) (const_int -126))
	       (le (minus (match_dup 0)(pc)) (const_int 126)))
	  (const_int 2)
	  (const_int 4)))
]
)

(define_insn "*condbranch_reverse_cmm"
  [(set (pc)
	(if_then_else (match_operator 1 "ordered_comparison_operator"
	                 [(reg CC_REG) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 0 "" ""))
        ))]	      
  "TARGET_CMM"
{
  return (get_attr_length (insn) == 2) ?
               "%P1\tbrs\t#%l0" :
	       "%P1\tbrw\t#%l0";
}
[(set_attr "conds" "use")
 (set (attr "length")
      (if_then_else 
          (and (ge (minus (match_dup 0)(pc)) (const_int -126))
	       (le (minus (match_dup 0)(pc)) (const_int 126)))
	  (const_int 2)
	  (const_int 4)))
]
)

(define_insn "*condbranch_lmm"
  [(set (pc)
	(if_then_else (match_operator 1 "ordered_comparison_operator"
	                [(reg CC_REG) (const_int 0)])
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  "TARGET_LMM && !TARGET_CMM"
{
  return (get_attr_length (insn) == 4) ?
               "%p1\tbrs\t#%l0" :
	       "%P1\tadd\tpc,#8\n\tjmp\t#__LMM_JMP\n\tlong\t%l0";
}
[(set_attr "conds" "use")
 (set (attr "length")
      (if_then_else 
          (and (ge (minus (match_dup 0)(pc)) (const_int -504))
	       (le (minus (match_dup 0)(pc)) (const_int 504)))
	  (const_int 4)
	  (const_int 12)))
]
)
(define_insn "*condbranch_lmm_reverse"
  [(set (pc)
	(if_then_else (match_operator 1 "ordered_comparison_operator"
	                 [(reg CC_REG) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 0 "" ""))
		      ))]
  "TARGET_LMM && !TARGET_CMM"
{
  return (get_attr_length (insn) == 4) ?
               "%P1\tbrs\t#%l0" :
	       "%p1\tadd\tpc,#8\n\tjmp\t#__LMM_JMP\n\tlong\t%l0";
}
[(set_attr "conds" "use")
 (set (attr "length")
      (if_then_else 
          (and (ge (minus (match_dup 0)(pc)) (const_int -504))
	       (le (minus (match_dup 0)(pc)) (const_int 504)))
	  (const_int 4)
	  (const_int 12)))
]
)


(define_insn "*condbranch_fcache"
  [(set (pc)
	(if_then_else (match_operator 2 "ordered_comparison_operator"
	                [(reg CC_REG) (const_int 0)])
		      (unspec [(label_ref (match_operand 0 "" ""))
		               (label_ref (match_operand 1 "" ""))]
			      UNSPEC_FCACHE_LABEL_REF)
		      (pc)))]
  ""
{
  return "%p2\tjmp\t#__LMM_FCACHE_START+(%l0-%l1)";
}
[(set_attr "conds" "use")
]
)

(define_insn "*condbranch_fcache_reverse"
  [(set (pc)
	(if_then_else (match_operator 2 "ordered_comparison_operator"
	                 [(reg CC_REG) (const_int 0)])
		      (pc)
		      (unspec [(label_ref (match_operand 0 "" ""))
		               (label_ref (match_operand 1 "" ""))]
			      UNSPEC_FCACHE_LABEL_REF)
        ))]
  ""
{
  return "%P2\tjmp\t#__LMM_FCACHE_START+(%l0-%l1)";
}
[(set_attr "conds" "use")
]
)

;; -------------------------------------------------------------------------
;; Call and Jump instructions
;; -------------------------------------------------------------------------

(define_expand "call"
  [(parallel [(call (match_operand:SI 0 "memory_operand" "")
		    (match_operand 1 "general_operand" ""))
	      (clobber (reg:SI LINK_REG))])]
  ""
{
  if (propeller_expand_call(NULL, operands[0], operands[1], false))
    DONE;
})

(define_expand "sibcall"
  [(parallel [(call (match_operand:SI 0 "memory_operand" "")
		    (match_operand 1 "general_operand" ""))
	      (return)]
   )]
  ""
{
  if (propeller_expand_call(NULL, operands[0], operands[1], true))
    DONE;
})

(define_insn "call_std"
  [(call (mem:SI (match_operand:SI 0 "call_operand" "i,r"))
	         (match_operand 1 "" ""))
   (clobber (reg:SI LINK_REG))
  ]
  "!TARGET_LMM"
  "@
   jmpret\tlr,#%0
   jmpret\tlr,%0"
  [(set_attr "type" "call")
   (set_attr "predicable" "yes")]
)

(define_insn "sibcall_std"
  [(call (mem:SI (match_operand:SI 0 "sibcall_operand" "i"))
	         (match_operand 1 "" ""))
   (return)
  ]
  "!TARGET_LMM"
  "jmp\t#%0"
  [(set_attr "type" "call")
   (set_attr "predicable" "yes")]
)

(define_insn "call_std_lmm"
  [(call (mem:SI (match_operand:SI 0 "call_operand" "i,r,U"))
	         (match_operand 1 "" ""))
   (clobber (reg:SI LINK_REG))
  ]
  "TARGET_LMM"
  "@
   lcall\t#%0
   mov\t__TMP0,%0\n\tjmp\t#__LMM_CALL_INDIRECT
   jmpret\tlr,#__LMM_FCACHE_START+8"
  [(set_attr "type" "call")
   (set_attr "length" "8")]
)
(define_insn "sibcall_std_lmm"
  [(call (mem:SI (match_operand:SI 0 "sibcall_operand" "i,U"))
	         (match_operand 1 "" ""))
   (return)
  ]
  "TARGET_LMM"
  "@
   jmp\t#__LMM_JMP\n\tlong\t%0
   jmp\t#__LMM_FCACHE_START+8"
  [(set_attr "type" "call")
   (set_attr "length" "8")]
)

;;
;; a special variant that does not clobber the link register (the return
;; address is stored directly into the corresponding ret instruction; so
;; this cannot be used for recursive functions!)
;;
(define_insn "call_native"
  [(call (mem:SI (match_operand:SI 0 "call_operand" "i,r"))
	         (match_operand 1 "" ""))
  ]
  ""
  "@
   call\t#%0
   call\t%0"
  [(set_attr "type" "call")
   (set_attr "predicable" "yes")]
)

(define_expand "call_value"
  [(parallel [(set (match_operand 0 "" "")
		     (call (match_operand:SI 1 "memory_operand" "")
		           (match_operand 2 "" "")))
              (clobber (reg:SI LINK_REG))])]
  ""
{
  if (propeller_expand_call(operands[0], operands[1], operands[2], false))
    DONE;
})

(define_expand "sibcall_value"
  [(parallel [(set (match_operand 0 "" "")
		     (call (match_operand:SI 1 "memory_operand" "")
		           (match_operand 2 "" "")))
              (return)]
    )]
  ""
{
  if (propeller_expand_call(operands[0], operands[1], operands[2], true))
    DONE;
})

(define_insn "*call_value"
  [(set (match_operand 0 "propeller_dst_operand" "=rC,rC")
	(call (mem:SI (match_operand:SI 1 "call_operand" "i,rC"))
	      (match_operand 2 "" "")))
   (clobber (reg:SI LINK_REG))
  ]
  "!TARGET_LMM"
  "@
   jmpret\tlr,#%1
   jmpret\tlr,%1"
  [(set_attr "type" "call")
   (set_attr "predicable" "yes")]
 )

(define_insn "*sibcall_value"
  [(set (match_operand 0 "propeller_dst_operand" "=rC")
	(call (mem:SI (match_operand:SI 1 "sibcall_operand" "i"))
	      (match_operand 2 "" "")))
   (return)
  ]
  "!TARGET_LMM"
  "jmp\t#%1"
  [(set_attr "type" "call")
   (set_attr "predicable" "yes")]
 )

(define_insn "*call_value_lmm"
  [(set (match_operand 0 "propeller_dst_operand" "=rC,rC,rC")
	(call (mem:SI (match_operand:SI 1 "call_operand" "i,rC,U"))
	      (match_operand 2 "" "")))
   (clobber (reg:SI LINK_REG))
  ]
  "TARGET_LMM"
  "@
   lcall\t#%1
   mov\t__TMP0,%1\n\tjmp\t#__LMM_CALL_INDIRECT
   jmpret\tlr,#__LMM_FCACHE_START+8"
  [(set_attr "type" "call")
   (set_attr "length" "8")]
 )

(define_insn "*sibcall_value_lmm"
  [(set (match_operand 0 "propeller_dst_operand" "=rC,rC")
	(call (mem:SI (match_operand:SI 1 "sibcall_operand" "i,U"))
	      (match_operand 2 "" "")))
   (return)
  ]
  "TARGET_LMM"
  "@
   jmp\t#__LMM_JMP\n\tlong\t%1
   jmp\t#__LMM_FCACHE_START+8"
  [(set_attr "type" "call")
   (set_attr "length" "8")]
 )

(define_insn "call_native_value"
  [(set (match_operand 0 "propeller_dst_operand" "=rC,rC")
        (call (mem:SI (match_operand:SI 1 "call_operand" "i,r"))
	         (match_operand 2 "" "")))
  ]
  ""
  "@
   call\t#%1
   call\t%1"
  [(set_attr "type" "call")
   (set_attr "predicable" "yes")]
)

(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "nonimmediate_operand" "rC"))]
  ""
{ if (TARGET_LMM)
    return "mov pc,%0";
  else
    return "jmp\t%0";
}
)

(define_expand "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  ""
)

(define_insn "*jump_std"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  "!TARGET_LMM"
  "jmp\t#%0"
)

;;
;; in fcache we give two labels, the target %0 and an anchor %1
;;
(define_insn "fcache_jump"
  [(set (pc)
	(unspec [(label_ref (match_operand 0 "" ""))
	         (label_ref (match_operand 1 "" ""))]
		UNSPEC_FCACHE_LABEL_REF))]
  ""
  "jmp\t#__LMM_FCACHE_START+(%0-%1)"
)

(define_insn "*jump_cmm"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  "TARGET_CMM"
{
  return (get_attr_length (insn) == 2) ?
               "brs\t#%l0" :
	       "brw\t#%l0";
}
[ (set (attr "length")
      (if_then_else 
          (and (ge (minus (match_dup 0)(pc)) (const_int -126))
	       (le (minus (match_dup 0)(pc)) (const_int 126)))
	  (const_int 2)
	  (const_int 4)))
]
)

(define_insn "*jump_lmm"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  "TARGET_LMM && !TARGET_CMM"
{
  return (get_attr_length (insn) == 4) ?
               "brs\t#%l0" :
	       "jmp\t#__LMM_JMP\n\tlong\t%l0";
}
[ (set (attr "length")
      (if_then_else 
          (and (ge (minus (match_dup 0)(pc)) (const_int -504))
	       (le (minus (match_dup 0)(pc)) (const_int 504)))
	  (const_int 4)
	  (const_int 8)))
]
)

;;
;; special code for starting an entire function that's been placed
;; in fcache
;;
(define_insn "fcache_func_start"
  [(unspec_volatile [(const_int 0)] UNSPEC_FCACHE_FUNC_START)]
  ""
  "mov\tpc,lr\n\tmov\tlr,__LMM_RET"
  [(set_attr "length" "8")
   (set_attr "type" "multi")]
)

;; and for jumping back
(define_insn "fcache_done"
  [(unspec_volatile [(const_int 0)] UNSPEC_FCACHE_DONE)]
  ""
  "jmp\t__LMM_RET\n\t.compress default"
  [(set_attr "length" "4")]
)

;; version of fcache_done for recursive functions
(define_insn "fcache_done_func"
  [(unspec_volatile [(const_int 1)] UNSPEC_FCACHE_DONE)]
  ""
  ".compress default"
  [(set_attr "length" "0")]
)

;; -------------------------------------------------------------------------
;; Prologue & Epilogue
;; -------------------------------------------------------------------------

(define_expand "prologue"
  [(clobber (const_int 0))]
  ""
  "
{
  propeller_expand_prologue ();
  DONE;
}
")

(define_expand "epilogue"
  [(return)]
  ""
  "
{
  propeller_expand_epilogue (false);
  DONE;
}
")

(define_expand "sibcall_epilogue"
  [(return)]
  ""
  "
{
  propeller_expand_epilogue (true);
  DONE;
}
")


(define_insn "return_in_fcache"
  [(unspec [(return)] UNSPEC_FCACHE_RET)
   (use (match_operand:SI 0 "register_operand" "r"))
  ]
  ""
{
    return "jmp\t%0";
}
)

(define_insn "return_internal"
  [(return)
   (use (match_operand:SI 0 "register_operand" "r"))
  ]
  ""
{ if (TARGET_CMM)
    return "lret";
  else if (TARGET_LMM)
    return "mov\tpc,%0";
  else
    return "jmp\t%0";
}
)

(define_insn "naked_return"
  [(unspec_volatile [(return)] UNSPEC_NAKED_RET) ]
  ""
  "' Naked function: epilogue provided by programmer."
  [(set_attr "length" "0")]
)

(define_insn "native_return"
  [(unspec_volatile [(return)] UNSPEC_NATIVE_RET)
   (use (match_operand:SI 0 "call_operand" ""))
  ]
  ""
  "'native return\n%0_ret\n\tret"
)

(define_expand "return"
  [(parallel [(return)
              (use (reg:SI LINK_REG))])
  ]
  "propeller_can_use_return ()"
  "")


;;
;; -------------------------------------------------------------------------
;; Low overhead looping
;; -------------------------------------------------------------------------
;;

(define_expand "doloop_begin"
  [(use (match_operand 0 "register_operand" ""))	; loop pseudo
   (use (match_operand 1 "" ""))	; iterations; zero if unknown
   (use (match_operand 2 "" ""))	; max iterations
   (use (match_operand 3 "" ""))	; loop level
  ]
""
{
  if (GET_MODE (operands[0]) == SImode && !TARGET_CMM)
    {
      if (INTVAL (operands[3]) > 1)
      	 FAIL;
      emit_insn (gen_doloop_begin_internal (operands[0], operands[0], operands[3]));
    }
  else
    FAIL;
  DONE;
}
)

(define_insn "doloop_begin_internal"
   [(set (match_operand:SI 0 "register_operand" "=r")
	(unspec_volatile:SI
	 [(match_operand:SI 1 "register_operand" "0")
	  (match_operand 2 "const_int_operand" "")] UNSPEC_LOOP_START))]
""
"'' loop_start register %0 level %2"
 [(set_attr "length" "0")]
)

(define_expand "doloop_end"
  [(use (match_operand 0 "" ""))	; loop pseudo
   (use (match_operand 1 "" ""))	; iterations; zero if unknown
   (use (match_operand 2 "" ""))	; max iterations
   (use (match_operand 3 "" ""))	; loop level
   (use (match_operand 4 "" ""))]	; label
""
{
  if (GET_MODE (operands[0]) == SImode && !TARGET_CMM)
    {
      if (INTVAL (operands[3]) > 1)
      	 FAIL;
      if (TARGET_LMM)
        emit_jump_insn (gen_djnz_lmm (operands[4], operands[0], operands[0]));
      else
        emit_jump_insn (gen_djnz (operands[4], operands[0], operands[0]));
    }
  else
    FAIL;
  DONE;
}
)

;; this is rather funky, because it has to be able to handle memory
;; operands due to the way reload works
;; we handle this by doing a split if the memory load is required

(define_insn_and_split "djnz"
  [(set (pc)
        (if_then_else
	  (ne (match_operand:SI 1 "propeller_dst_operand" "rC,rC,rC")
	      (const_int 1))
	  (label_ref (match_operand 0 "" ""))
	  (pc)))
   (set (match_operand:SI 2 "nonimmediate_operand" "=1,?X,?X")
        (plus:SI (match_dup 1)(const_int -1)))
   (clobber (match_scratch:SI 3 "=X,&1,&?r"))
  ]
"!TARGET_LMM"
{
 if (which_alternative != 0)
   return "#";
 return "djnz\\t%1,#%l0";
}
 "&& reload_completed
  && (! REG_P (operands[2]) || ! rtx_equal_p (operands[1], operands[2]))"
 [(set (match_dup 3)(match_dup 1))
  (parallel
    [(set (reg:CC_Z CC_REG)
          (compare:CC_Z (plus:SI (match_dup 3)(const_int -1))
	                (const_int 0)))
      (set (match_dup 3)(plus:SI (match_dup 3)(const_int -1)))])
  (set (match_dup 2)(match_dup 3))
  (set (pc) (if_then_else (ne (reg:CC_Z CC_REG)(const_int 0))
                          (label_ref (match_dup 0))
                          (pc)))]
 ""
 [(set_attr "type" "core,multi,multi")
  (set_attr "length" "4,16,16")
 ]
)

(define_insn_and_split "djnz_lmm"
  [(set (pc)
        (if_then_else
	  (ne (match_operand:SI 1 "propeller_dst_operand" "rC,rC,rC")
	      (const_int 1))
	  (label_ref (match_operand 0 "" ""))
	  (pc)))
   (set (match_operand:SI 2 "nonimmediate_operand" "=1,?X,?X")
        (plus:SI (match_dup 1)(const_int -1)))
   (clobber (match_scratch:SI 3 "=X,&1,&?r"))
  ]
"TARGET_LMM && !TARGET_CMM"
{
 if (which_alternative != 0)
   return "#";
 return "djnz\\t%1,#__LMM_JMP\\n\\tlong\\t%l0";
}
 "&& reload_completed
  && (! REG_P (operands[2]) || ! rtx_equal_p (operands[1], operands[2]))"
 [(set (match_dup 3)(match_dup 1))
  (parallel
    [(set (reg:CC_Z CC_REG)
          (compare:CC_Z (plus:SI (match_dup 3)(const_int -1))
	                (const_int 0)))
      (set (match_dup 3)(plus:SI (match_dup 3)(const_int -1)))])
  (set (match_dup 2)(match_dup 3))
  (set (pc) (if_then_else (ne (reg:CC_Z CC_REG)(const_int 0))
                          (label_ref (match_dup 0))
                          (pc)))]
 ""
 [(set_attr "type" "multi,multi,multi")
  (set_attr "length" "8,16,16")
 ]
)

(define_insn_and_split "*djnz_fcache"
  [(set (pc)
        (if_then_else
	  (ne (match_operand:SI 1 "propeller_dst_operand" "rC,rC,rC")
	      (const_int 1))
	  (unspec [(label_ref (match_operand 0 "" ""))
                   (label_ref (match_operand 4 "" ""))]
                  UNSPEC_FCACHE_LABEL_REF)
	  (pc)))
   (set (match_operand:SI 2 "nonimmediate_operand" "=1,?X,?X")
        (plus:SI (match_dup 1)(const_int -1)))
   (clobber (match_scratch:SI 3 "=X,&1,&?r"))
  ]
""
{
 if (which_alternative != 0)
   return "#";
 return "djnz\\t%1,#__LMM_FCACHE_START+(%l0-%l4)";
}
 "&& reload_completed
  && (! REG_P (operands[2]) || ! rtx_equal_p (operands[1], operands[2]))"
 [(set (match_dup 3)(match_dup 1))
  (parallel
    [(set (reg:CC_Z CC_REG)
          (compare:CC_Z (plus:SI (match_dup 3)(const_int -1))
	                (const_int 0)))
      (set (match_dup 3)(plus:SI (match_dup 3)(const_int -1)))])
  (set (match_dup 2)(match_dup 3))
  (set (pc) (if_then_else (ne (reg:CC_Z CC_REG)(const_int 0))
                          (label_ref (match_dup 0))
                          (pc)))]
 ""
 [(set_attr "type" "core,multi,multi")
  (set_attr "length" "4,16,16")
 ]
)


;; -------------------------------------------------------------------------
;; Some library functions
;; -------------------------------------------------------------------------
;;
;; count leading zeros
;;

(define_insn "*prop_clzsi2"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (clz:SI (reg:SI 0)))
   (clobber (reg:CC CC_REG))]
""
{
  propeller_need_clzsi = true;
  return "call\t#__CLZSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")]
)

;; count trailing zeros
(define_insn "*prop_ctzsi2"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (ctz:SI (reg:SI 0)))
   (clobber (reg:CC CC_REG))]
""
{
  propeller_need_clzsi = true;
  return "jmpret\t__CLZSI_ret,#__CTZSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")]
)

(define_expand "clzsi2"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(clz:SI (reg:SI 0)))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
  ]
""
""
)

(define_expand "ctzsi2"
  [(set (reg:SI 0)(match_operand:SI 1 "propeller_src_operand" ""))
   (parallel[
     (set (reg:SI 0)(ctz:SI (reg:SI 0)))
     (clobber (reg:CC CC_REG))])
   (set (match_operand:SI 0 "propeller_dst_operand" "")(reg:SI 0))
  ]
""
""
)

;; parity calculation
(define_expand "paritysi2"
  [(set (reg:CC_C CC_REG)
        (compare:CC_C
	  (const_int 0)
	  (parity:SI (and:SI
	      (match_operand:SI 1 "propeller_dst_operand" "rC")
	      (const_int -1)))))
   (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (if_then_else:SI (ltu (reg:CC_C CC_REG)(const_int 0))
	              (const_int 1)
		      (const_int 0)))
   ]
   ""
   ""
)

;;
;; string operations
;; these are still experimental!
;;
(define_insn "prop_movmem"
  [(set (mem:BLK (reg:SI 0))
        (mem:BLK (reg:SI 1)))
   (use (reg:SI 2))
   (unspec_volatile:BLK [(reg:SI 0) (reg:SI 1) (reg:SI 2)] UNSPEC_MOVMEM)
   (clobber (reg:SI 0))
   (clobber (reg:SI 1))
   (clobber (reg:SI 2))
   (clobber (reg:SI 3))
   (clobber (reg:CC CC_REG))
  ]
"TARGET_BUILTIN_STRINGS"
{
    return "call\t#__Memcpy";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "clob")
 ]
)

(define_expand "movmemsi"
  [(parallel
    [(set (match_operand:BLK 0 "memory_operand")    ;; Dest
          (match_operand:BLK 1 "memory_operand"))   ;; Source
     (use (match_operand:SI 2 "register_operand"))  ;; length in bytes
     (match_operand 3 "immediate_operand")          ;; align
     (unspec_volatile:BLK [(reg:SI 0) (reg:SI 1) (reg:SI 2)] UNSPEC_MOVMEM)
    ])
  ]
"TARGET_BUILTIN_STRINGS"
{
  rtx dstaddr = gen_rtx_REG (SImode, 0);
  rtx srcaddr = gen_rtx_REG (SImode, 1);
  rtx len = gen_rtx_REG(SImode, 2);

  if (REG_P (operands[0]) && (REGNO (operands[0]) == 1 
     	    		      || REGNO (operands[0]) == 2))
     FAIL;
  if (REG_P (operands[1]) && (REGNO (operands[1]) == 0 
     	    		      || REGNO (operands[1]) == 2))
     FAIL;
  if (REG_P (operands[2]) && (REGNO (operands[2]) == 0 
     	    		      || REGNO (operands[2]) == 1))
     FAIL;

  emit_move_insn (dstaddr, force_operand (XEXP (operands[0], 0), NULL_RTX));
  emit_move_insn (srcaddr, force_operand (XEXP (operands[1], 0), NULL_RTX));
  emit_move_insn (len, force_operand (operands[2], NULL_RTX));

  operands[0] = replace_equiv_address_nv (operands[0], dstaddr);
  operands[1] = replace_equiv_address_nv (operands[1], srcaddr);
  emit_insn (gen_prop_movmem ());
  DONE;
}
)


;; -------------------------------------------------------------------------
;; synchronization insns
;; -------------------------------------------------------------------------
;; We must use a pseudo-reg forced to reg 0 in the SET_DEST rather than
;; hard register 0.  If we used hard register 0, then the next instruction
;; would be a move from hard register 0 to a pseudo-reg, which could cause
;; problems.

;; compare and swap; this is implemented as a function, and only works
;; on memory locations that all threads treat as special

;; register usage of the function:
;; input: r0 == new value for memory, r1 == old value for memory, r2 == pointer to memory
;; output: r0 == original value for memory

(define_insn "*sync_compare_and_swapsi"
  [(set (match_operand:SI 0 "register_operand" "=z")
        (mem:SI (reg:SI 2)))
   (set (mem:SI (reg:SI 2))
        (unspec_volatile:SI
	  [(mem:SI (reg:SI 2))
	   (reg:SI 1)
	   (reg:SI 0)]
          UNSPEC_CAS))
   (set (reg:CC_Z CC_REG)
        (compare:CC_Z (mem:SI (reg:SI 2))(reg:SI 1)))
  ]
""
{
  propeller_need_cmpswapsi = true;
  return "call\t#__CMPSWAPSI";
}
 [(set_attr "type" "multi")
  (set_attr "conds" "set")
 ]
)

;;
;; operand 0: result, namely the original value of the memory
;; operand 1: memory location for test and swap
;; operand 2: old value required (compare against)
;; operand 3: new value to set if operand 1 == operand 2
;; we synthesize operand 4 to be the address of operand 1
;;
(define_expand "sync_compare_and_swapsi"
  [(set (reg:SI 0)(match_operand:SI 3 "propeller_src_operand" ""))
   (set (reg:SI 1)(match_operand:SI 2 "propeller_src_operand" ""))
   (use (match_operand:SI 1 "memory_operand" ""))
   (set (reg:SI 2)(match_dup 4))
   (parallel[
     (set (match_operand:SI 0 "register_operand" "z")
          (mem:SI (reg:SI 2)))
     (set (mem:SI (reg:SI 2))
          (unspec_volatile:SI
	    [(mem:SI (reg:SI 2))
             (reg:SI 1)
             (reg:SI 0)]
            UNSPEC_CAS))
     (set (reg:CC_Z CC_REG)
          (compare:CC_Z (mem:SI (reg:SI 2))(reg:SI 1)))
     ])
  ]
""
{
  /* make sure address of operands[1] is a register */
  if (!REG_P (XEXP (operands[1], 0)))
    {
      operands[1] = shallow_copy_rtx (operands[1]);
      XEXP (operands[1], 0) = force_reg (Pmode, XEXP (operands[1], 0));
    }
  operands[4] = XEXP (operands[1], 0);
}
)

;; -------------------------------------------------------------------------
;; Special insns for built in instructions
;; -------------------------------------------------------------------------

;; cogid is an unspec_volatile because threads may switch between
;; processors
(define_insn "cogid"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
       (unspec_volatile:SI [(const_int 0)] UNSPEC_COGID))
  ]
  ""
  "cogid\t%0"
  [(set_attr "type" "hub")
   (set_attr "predicable" "yes")]
)

;;
;; we split coginit up into 2 insns, one to start the cog and the
;; second to update its state from the carry flag
;; the coginit raw sets the carry flag to mean that the locknew failed,
;; which means that the register is to be set to -1 (i.e. < 0)
;;
(define_insn "*coginit_raw"
  [
    (set (reg:CC_C CC_REG)
         (compare:CC_C
	   (const_int 0)
	   (unspec [(match_operand:SI 1 "propeller_dst_operand" "0")]
	           UNSPEC_COGSTATE)))
    (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
       (unspec_volatile:SI
         [(match_dup 1)] UNSPEC_COGINIT))
  ]
  ""
  "coginit\t%0 wc,wr"
  [(set_attr "type" "hub")
   (set_attr "predicable" "yes")]
)

(define_insn_and_split "coginit"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=&rC")
        (unspec_volatile:SI [(match_operand:SI 1 "propeller_dst_operand" "0")]
	        UNSPEC_COGSTATE))
   ]
  ""
  "#"
  "reload_completed"
  [(parallel
     [(set (reg:CC_C CC_REG)
           (compare:CC_C
               (const_int 0)
	       (unspec [(match_dup 1)] UNSPEC_COGSTATE)))
      (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
       (unspec_volatile:SI
         [(match_dup 1)] UNSPEC_COGINIT))
      ])
   (set (match_dup 0)
         (if_then_else:SI (ltu (reg:CC_C CC_REG)(const_int 0))
                       (const_int -1)
                       (match_dup 0)))
   ]
   ""
   [(set_attr "conds" "set")
    (set_attr "length" "8")]
)

(define_insn "cogstop"
  [(unspec_volatile [(match_operand:SI 0 "propeller_dst_operand" "rC")]
      UNSPEC_COGSTOP)]
  ""
  "cogstop\t%0"
  [(set_attr "type" "hub")
   (set_attr "predicable" "yes")]
)

(define_insn "clkset"
  [(unspec_volatile [(match_operand:SI 0 "propeller_dst_operand" "rC")]
      UNSPEC_CLKSET)]
  ""
  "clkset\t%0"
  [(set_attr "type" "hub")
   (set_attr "predicable" "yes")]
)

(define_insn "reverse"
  [(set (match_operand:SI          0 "propeller_dst_operand" "=rC")
        (unspec:SI [(match_operand:SI 1 "propeller_dst_operand" "0")
                 (match_operand:SI 2 "propeller_src_operand" "rCI")]
	  UNSPEC_REVERSE))]
  ""
  "rev\t%0,%2"
  [(set_attr "predicable" "yes")]
)

;; allocate and return locks
(define_insn "*locknew_internal"
  [(set (reg:CC_C CC_REG)
        (compare:CC_C
	  (const_int 0)
	  (unspec [(const_int UNSPEC_LOCKNEW)] UNSPEC_LOCKSTATE)))
   (set (match_operand:SI 0 "propeller_dst_operand" "=rC")
        (unspec_volatile:SI [(const_int 0)] UNSPEC_LOCKNEW))]
  ""
  "locknew\t%0 wc"
  [(set_attr "predicable" "yes")
   (set_attr "type" "hub")]
)
(define_insn_and_split "locknew"
   [(set (match_operand:SI 0 "propeller_dst_operand" "=rC")
         (unspec_volatile:SI [(const_int UNSPEC_LOCKNEW)] UNSPEC_LOCKSTATE))]
  ""
  "#"
  "reload_completed"
  [(parallel
     [(set (reg:CC_C CC_REG)
           (compare:CC_C
               (const_int 0)
	       (unspec [(const_int UNSPEC_LOCKNEW)] UNSPEC_LOCKSTATE)))
      (set (match_dup 0)(unspec_volatile:SI [(const_int 0)] UNSPEC_LOCKNEW))
      ])
    (set (match_dup 0)
         (if_then_else:SI (ltu (reg:CC_C CC_REG)(const_int 0))
                       (const_int -1)
                       (match_dup 0)))
   ]
   ""
   [(set_attr "conds" "set")
    (set_attr "length" "8")]
)

(define_insn "lockret"
  [(unspec_volatile [(match_operand:SI 0 "propeller_dst_operand" "rC")]
                    UNSPEC_LOCKRET)]
  ""
  "lockret\t%0"
  [(set_attr "predicable" "yes")
   (set_attr "type" "hub")]
)
;; clear lock
(define_insn "lockclr"
  [(unspec_volatile [(match_operand:SI 0 "propeller_dst_operand" "rC")]
                    UNSPEC_LOCKCLR)]
  ""
  "lockclr\t%0"
  [(set_attr "predicable" "yes")
   (set_attr "type" "hub")]
)

;; set lock
;; this needs to be split into 2 insns, one to set the lock and the
;; second to update its state from the carry flag
;; the lockset raw sets the carry flag to mean that the locknew failed,
;; which will mean that the register is to be set to -1 (i.e. < 0)

(define_insn "*lockset_raw"
  [ (set (reg:CC_C CC_REG)
         (compare:CC_C
	   (const_int 0)
	   (unspec [(match_operand:SI 0 "propeller_dst_operand" "rC")]
	           UNSPEC_LOCKSTATE)))
    (unspec_volatile [(match_dup 0)]
                    UNSPEC_LOCKSET)]
  ""
  "lockset\t%0 wc"
  [(set_attr "predicable" "yes")
   (set_attr "type" "hub")]
)

(define_insn_and_split "lockset"
  [(set (match_operand:SI 0 "propeller_dst_operand" "=&rC")
        (unspec:SI [(match_operand:SI 1 "propeller_dst_operand" "rC")]
	        UNSPEC_LOCKSTATE))
   (unspec_volatile [(match_dup 1)] UNSPEC_LOCKSET)]
  ""
  "#"
  "reload_completed"
  [(parallel
     [(set (reg:CC_C CC_REG)
           (compare:CC_C
               (const_int 0)
	       (unspec [(match_dup 1)] UNSPEC_LOCKSTATE)))
       (unspec_volatile [(match_dup 1)] UNSPEC_LOCKSET) ])
    (set (match_dup 0)
         (if_then_else:SI (ltu (reg:CC_C CC_REG)(const_int 0))
                       (const_int -1)
                       (const_int 0)))
   ]
   ""
   [(set_attr "conds" "set")
    (set_attr "length" "8")]
)


;;
;; waitcnt
;; we originally defined "waitcnt A,B" to say that it calculated
;; A := A+B as well as waiting, but this proved to be problematic
;; (GCSE wanted to merge the calculations but then crashed on the
;; unspec_volatile)
;;
;;(define_insn "waitcnt"
;;  [(set (match_operand:SI       0 "propeller_dst_operand" "=rC")
;;        (plus:SI (match_operand:SI 1 "propeller_dst_operand" "0")
;;              (match_operand:SI 2 "propeller_src_operand" "rCI")))
;;   (unspec_volatile [(match_dup 1)] UNSPEC_WAITCNT)]
;;  ""
;;  "waitcnt\t%0,%2"
;;  [(set_attr "type" "wait")
;;   (set_attr "predicable" "yes")]
;;)

(define_insn "waitcnt"
  [(set (match_operand:SI       0 "propeller_dst_operand" "=rC")
        (unspec_volatile [
	      (match_operand:SI 1 "propeller_dst_operand" "0")
              (match_operand:SI 2 "propeller_src_operand" "rCI")]
	      UNSPEC_WAITCNT))]
  ""
  "waitcnt\t%0,%2"
  [(set_attr "type" "wait")
   (set_attr "predicable" "yes")]
)

(define_insn "waitpeq"
  [(unspec_volatile
     [(match_operand:SI 0 "propeller_dst_operand" "rC")
      (match_operand:SI 1 "propeller_src_operand" "rCI")]
     UNSPEC_WAITPEQ)]
  ""
  "waitpeq\t%0,%1"
  [(set_attr "type" "wait")
   (set_attr "predicable" "yes")]
)

(define_insn "waitpne"
  [(unspec_volatile
     [(match_operand:SI 0 "propeller_dst_operand" "rC")
      (match_operand:SI 1 "propeller_src_operand" "rCI")]
     UNSPEC_WAITPNE)]
  ""
  "waitpne\t%0,%1"
  [(set_attr "predicable" "yes")
   (set_attr "type" "wait")]
)

(define_insn "waitvid"
  [(unspec_volatile
     [(match_operand:SI 0 "propeller_dst_operand" "rC")
      (match_operand:SI 1 "propeller_src_operand" "rCI")]
     UNSPEC_WAITVID)]
  ""
  "waitvid\t%0,%1"
  [(set_attr "type" "wait")
   (set_attr "predicable" "yes")]
)

;;
;; fcache load 
;; parameters are the start and stop labels where we should do the load
;;
(define_insn "fcache_load"
  [(unspec_volatile
    [(label_ref (match_operand 0 "" ""))
     (label_ref (match_operand 1 "" ""))]
    UNSPEC_FCACHE_LOAD)]
  ""
  {
	if (TARGET_CMM) {
	  return "fcache #(%1-%0)\n\t.compress off\n";
        }
	return "jmp\t#__LMM_FCACHE_LOAD\n\tlong\t%1-%0";
  }
  [(set_attr "type" "multi")
   (set_attr "length" "8")]
)

;;
;; define a word of data
;;
(define_insn "fcache_const_word"
  [(unspec_volatile
    [(use (match_operand:SI 0 "immediate_operand" "i"))]
    UNSPEC_CONST_WORD)]
""
".long %c0"
)


;; -------------------------------------------------------------------------
;; machine specific peepholes to catch things the combiner misses
;; -------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; mov rn, sp / add rn,#X -> leasp rn, #X
;; 
(define_peephole2
  [(set (match_operand:SI 0 "register_operand" "")
        (reg:SI SP_REG))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                  (match_operand:SI 1 "immediate_byte" "")))
  ]
  "TARGET_CMM"
  [(set (match_dup 0) (plus:SI (reg:SI SP_REG) (match_dup 1)))
  ]
  ""
)

;;
;; mov rn, #X / add rn,sp -> leasp rn, #X
;; 

(define_peephole2
  [(set (match_operand:SI 0 "register_operand" "")
        (match_operand:SI 1 "immediate_byte" ""))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                  (reg:SI SP_REG)))
  ]
  "TARGET_CMM"
  [(set (match_dup 0) (plus:SI (reg:SI SP_REG) (match_dup 1)))
  ]
  ""
)

;;
;; move followed by a redundant compare
;;
(define_peephole2
  [(set (match_operand:SI 0 "propeller_dst_operand" "")
        (match_operand:SI 1 "propeller_src_operand" ""))
   (set (reg:CC_Z CC_REG)(compare:CC_Z (match_dup 1) (const_int 0)))
  ]
  ""
  [(parallel
     [(set (reg:CC_Z CC_REG)(compare:CC_Z (match_dup 1)(const_int 0)))
      (set (match_dup 0)(match_dup 1))])]
  ""
)
(define_peephole2
  [(set (match_operand:SI 0 "propeller_dst_operand" "")
        (match_operand:SI 1 "propeller_src_operand" ""))
   (set (reg:CC CC_REG)(compare:CC (match_dup 0) (const_int 0)))
  ]
  ""
  [(parallel
     [(set (reg:CC CC_REG)(compare:CC (match_dup 1)(const_int 0)))
      (set (match_dup 0)(match_dup 1))])]
  ""
)

;;
;; sometimes the combiner will miss redundant compares
;;
(define_peephole2
  [(set (match_operand:SI 0 "propeller_dst_operand" "")
        (match_operator:SI 2 "propeller_math_op2"
	   [(match_dup 0)
	    (match_operand:SI 1 "propeller_src_operand" "")
	   ]))
   (set (reg:CC_Z CC_REG)(compare:CC_Z (match_dup 0) (const_int 0)))
  ]
  ""
  [(parallel
     [(set (reg:CC_Z CC_REG)
             (compare:CC_Z (match_op_dup 2 [(match_dup 0)(match_dup 1)])
	                   (const_int 0)))
      (set (match_dup 0)
           (match_op_dup 2 [(match_dup 0)(match_dup 1)]))
     ])]
  ""
)

;;
;; abs and neg set their flags based on source input rather than
;; on output; for 0 comparisons this actually works for the output
;; too, since abs(0) = neg(0) = 0
;;

;; set flags based on source; note that we require that operands[1]
;; become dead so as to avoid the case where operands[0] and operands[1]
;; are the same
(define_peephole2
  [(set (match_operand:SI 0 "propeller_dst_operand" "")
        (match_operator:SI 2 "propeller_math_op1srcflags"
	   [
	    (match_operand:SI 1 "propeller_src_operand" "")
	   ]))
   (set (reg:CC CC_REG)(compare:CC (match_dup 1) (const_int 0)))
  ]
  "peep2_reg_dead_p (2, operands[1])"
  [(parallel
     [(set (reg:CC CC_REG)
             (compare:CC   (match_dup 1)
	                   (const_int 0)))
      (set (match_dup 0)
           (match_op_dup 2 [(match_dup 1)]))
     ])]
  ""
)

(define_peephole2
  [(set (match_operand:SI 0 "propeller_dst_operand" "")
        (match_operator:SI 2 "propeller_math_op1"
	   [
	    (match_operand:SI 1 "propeller_src_operand" "")
	   ]))
   (set (reg:CC_Z CC_REG)(compare:CC_Z (match_dup 1) (const_int 0)))
  ]
  ""
  [(parallel
     [(set (reg:CC_Z CC_REG)
             (compare:CC_Z (match_op_dup 2 [(match_dup 1)])
	                   (const_int 0)))
      (set (match_dup 0)
           (match_op_dup 2 [(match_dup 1)]))
     ])]
  ""
)
;;
;; reload will generate constant pool addresses for a lot of things
;; if those fall in cog memory, we can optimize away the move to register
;;
;; NOTE: the first operand to peep2_reg_dead_p is the number of instructions
;; after which the register should be dead; this will normally be the
;; number of insns matched by the peephole (?)

;; convert
;;  (set r2 N)
;;  (set r0 (OP r0 r2))
;; into
;;  (set r0 (OP r0 N))
;; when r2 is dead

(define_peephole2
  [(set (match_operand:SI 2 "register_operand" "")
        (match_operand:SI 1 "propeller_src_operand" ""))
   (set (match_operand:SI 0 "propeller_dst_operand" "")
        (match_operator:SI 3  "propeller_math_op2"
         [(match_dup 0)
          (match_dup 2)]))
  ]
  "peep2_reg_dead_p (2, operands[2])"
  [(set (match_dup 0)
        (match_op_dup 3 [(match_dup 0)(match_dup 1)]))]
  ""
)

;; convert
;;  (set r2 N)
;;  (set r0 (OP r2))
;; into
;;  (set r0 (OP N))
;; when r2 is dead

(define_peephole2
  [(set (match_operand:SI 2 "register_operand" "")
        (match_operand:SI 1 "propeller_src_operand" ""))
   (set (match_operand:SI 0 "propeller_dst_operand" "")
        (match_operator:SI 3  "propeller_math_op1"
         [(match_dup 2)]))
  ]
  "peep2_reg_dead_p (2, operands[2])"
  [(set (match_dup 0)
        (match_op_dup 3 [(match_dup 0)(match_dup 1)]))]
  ""
)

;;
;; needless move
;;
(define_peephole2
  [(set (match_operand:SI 0 "register_operand" "")
        (match_operand:SI 1 "propeller_dst_operand" ""))
   (set (match_dup 1)(match_dup 0))
  ]
  "peep2_reg_dead_p (2, operands[0]) && !(MEM_P (operands[1]) && MEM_VOLATILE_P (operands[1]))"
  [(const_int 0)]
  ""
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; old-style peepholes: these work at the very end of compilation
;; and can occasionally catch issues that are missed by earlier
;; passes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; these don't come up terribly often, but are provided here just as
;; examples of how peepholes can be defined

;;
;; sumz r0,r1:  r0 = (z flag set) ? r0 - r1 : r0 + r1
;;

(define_peephole
 [
  (cond_exec (eq (reg:CC_Z CC_REG) (const_int 0))
    (set (match_operand:SI 0 "register_operand" "=r")
         (minus:SI (match_dup 0)
                  (match_operand:SI 1 "register_operand" "r"))))
  (cond_exec (ne (reg:CC_Z CC_REG) (const_int 0))
    (set (match_dup 0)
         (plus:SI (match_dup 0)
                  (match_dup 1))))
  ]
  ""
  "sumz\t%0,%1"
)

;;
;; sumz r0,r1:  r0 = (z flag set) ? r0 - r1 : r0 + r1
;;

(define_peephole
 [
  (cond_exec (ne (reg:CC_Z CC_REG) (const_int 0))
    (set (match_operand:SI 0 "register_operand" "=r")
         (minus:SI (match_dup 0)
                  (match_operand:SI 1 "register_operand" "r"))))
  (cond_exec (eq (reg:CC_Z CC_REG) (const_int 0))
    (set (match_dup 0)
         (plus:SI (match_dup 0)
                  (match_dup 1))))
  ]
  ""
  "sumnz\t%0,%1"
)

;;
;; optimize sequences like:
;; (set r0 OUTA)
;; (set r0 (XOR r0 1))
;; (set OUTA r0)
;; which happen because OUTA is volatile and hence not subject to
;; combining
;; make sure r0 is dead before doing this though!
;;
(define_peephole
  [
    (set (match_operand:SI 0 "propeller_dst_operand" "")
         (match_operand:SI 1 "propeller_dst_operand" ""))
    (set (match_dup 0)
         (match_operator:SI 3 "propeller_pair_op2"
          [(match_dup 0)
           (match_operand:SI 2 "propeller_src_operand" "")]))
    (set (match_dup 1)(match_dup 0))
   ]
  "propeller_reg_dead_peep (insn, operands[0])"
  "%Q3\t%1,%2"
)

(define_peephole
  [
    (set (match_operand:SI 0 "propeller_dst_operand" "")
         (match_operand:SI 1 "propeller_dst_operand" ""))
    (set (match_dup 0)
         (and:SI (match_dup 0)
	         (not:SI (match_operand:SI 2 "propeller_src_operand" ""))))
    (set (match_dup 1)(match_dup 0))
   ]
  "propeller_reg_dead_peep (insn, operands[0])"
  "andn\t%1,%2"
)

(define_peephole
  [
    (set (match_operand:SI 0 "propeller_dst_operand" "")
         (match_operand:SI 1 "propeller_dst_operand" ""))
    (set (match_dup 0)
         (and:SI (match_dup 0)
	         (match_operand:SI 2 "const_int_operand" "")))
    (set (match_dup 1)(match_dup 0))
   ]
  "propeller_reg_dead_peep (insn, operands[0]) && propeller_const_ok_for_letter_p (INTVAL (operands[2]), 'M')"
  "andn\t%1, %M2"
)

;;
;; instruction pairing for CMM mode
;;
(define_peephole
 [
  (set (match_operand:SI 0 "propeller_gpr_operand" "=r")
       (match_operand:SI 1 "propeller_gpr_operand" "r"))
  (set (match_operand:SI 2 "propeller_gpr_operand" "=r")
       (match_operator:SI 4 "propeller_pair_op2"
         [(match_dup 2)
          (match_operand:SI 3 "propeller_cmm_src_operand" "ri")]))
  ]
  "TARGET_CMM"
  "xmov\t%0,%1 %Q4 %2,%3"
)

;; we have to special case sub r0,#1, it gets turned into add r0,#-1
(define_peephole
 [
  (set (match_operand:SI 0 "propeller_gpr_operand" "=r")
       (match_operand:SI 1 "propeller_gpr_operand" "r"))
  (set (match_operand:SI 2 "propeller_gpr_operand" "=r")
       (plus:SI (match_dup 2)
                (match_operand:SI 3 "negative_nybble" "n")))
  ]
  "TARGET_CMM"
  "xmov\t%0,%1 sub %2,#%n3"
)

(define_peephole
 [
  (set (match_operand:SI 0 "propeller_gpr_operand" "=r")
       (match_operand:SI 1 "propeller_gpr_operand" "r"))
  (set (match_operand:SI 2 "propeller_gpr_operand" "=r")
       (match_operand:SI 3 "propeller_gpr_operand" "r"))
  ]
  "TARGET_CMM"
  "xmov\t%0,%1 mov %2,%3"
)

;;
;; stack optimizations
;;

;; combine pop + ret
(define_peephole
 [
  (match_parallel 1 "propeller_load_multiple_vector"
     [(set (reg:SI SP_REG)
	   (plus:SI (reg:SI SP_REG)
		    (match_operand:SI 0 "const_int_operand" "n")))]
   )
   (parallel [(return)
              (use (reg:SI LINK_REG))]
   )
 ]
 "TARGET_LMM"
 {
    propeller_emit_stack_popm (operands, 1);
    return "";
 }
)

;; use lpushm for single push

(define_peephole
  [(set (reg:SI SP_REG)
        (plus:SI (reg:SI SP_REG) (const_int -4)))
   (set (mem:SI (reg:SI SP_REG)) (match_operand:SI 0 "propeller_gpr_operand" "r"))
  ]
  "TARGET_CMM"
  {
    asm_fprintf (asm_out_file, "\tlpushm\t#16+%d\n", REGNO(operands[0]));
    return "";
  }
)

(define_peephole
  [
   (set (match_operand:SI 0 "propeller_gpr_operand" "=r")
        (mem:SI (reg:SI SP_REG)))
   (set (reg:SI SP_REG)
        (plus:SI (reg:SI SP_REG) (const_int 4)))
   (parallel [(return)
              (use (reg:SI LINK_REG))])
  ]
  "TARGET_CMM"
  {
    asm_fprintf (asm_out_file, "\tlpopret\t#16+%d\n", REGNO(operands[0]));
    return "";
  }
)
